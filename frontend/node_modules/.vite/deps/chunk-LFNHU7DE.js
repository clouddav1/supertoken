import {
  require_react
} from "./chunk-GCG7DT74.js";
import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/supertokens-web-js/lib/build/normalisedURLPath.js
var require_normalisedURLPath = __commonJS({
  "node_modules/supertokens-web-js/lib/build/normalisedURLPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NormalisedURLPath = function() {
      function NormalisedURLPath2(url) {
        var _this = this;
        this.startsWith = function(other) {
          return _this.value.startsWith(other.value);
        };
        this.appendPath = function(other) {
          return new NormalisedURLPath2(_this.value + other.value);
        };
        this.getAsStringDangerous = function() {
          return _this.value;
        };
        this.value = normaliseURLPathOrThrowError(url);
      }
      return NormalisedURLPath2;
    }();
    exports.default = NormalisedURLPath;
    function normaliseURLPathOrThrowError(input) {
      input = input.trim();
      try {
        if (!input.startsWith("http://") && !input.startsWith("https://")) {
          throw new Error("Error converting to proper URL");
        }
        var urlObj = new URL(input);
        input = urlObj.pathname;
        if (input.charAt(input.length - 1) === "/") {
          return input.substr(0, input.length - 1);
        }
        return input;
      } catch (err) {
      }
      if ((domainGiven(input) || input.startsWith("localhost")) && !input.startsWith("http://") && !input.startsWith("https://")) {
        input = "http://" + input;
        return normaliseURLPathOrThrowError(input);
      }
      if (input.charAt(0) !== "/") {
        input = "/" + input;
      }
      try {
        new URL("http://example.com" + input);
        return normaliseURLPathOrThrowError("http://example.com" + input);
      } catch (err) {
        throw new Error("Please provide a valid URL path");
      }
    }
    function domainGiven(input) {
      if (input.indexOf(".") === -1 || input.startsWith("/")) {
        return false;
      }
      try {
        var url = new URL(input);
        return url.hostname.indexOf(".") !== -1;
      } catch (e) {
      }
      try {
        var url = new URL("http://" + input);
        return url.hostname.indexOf(".") !== -1;
      } catch (e) {
      }
      return false;
    }
  }
});

// node_modules/supertokens-website/lib/build/utils/windowHandler/defaultImplementation.js
var require_defaultImplementation = __commonJS({
  "node_modules/supertokens-website/lib/build/utils/windowHandler/defaultImplementation.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultWindowHandlerImplementation = void 0;
    function getWindowOrThrow() {
      if (typeof window === "undefined") {
        throw Error(
          "If you are using this package with server-side rendering, please make sure that you are checking if the window object is defined."
        );
      }
      return window;
    }
    var defaultLocalStorageHandler = {
      key: function(index) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, getWindowOrThrow().localStorage.key(index)];
          });
        });
      },
      clear: function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, getWindowOrThrow().localStorage.clear()];
          });
        });
      },
      getItem: function(key) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, getWindowOrThrow().localStorage.getItem(key)];
          });
        });
      },
      removeItem: function(key) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, getWindowOrThrow().localStorage.removeItem(key)];
          });
        });
      },
      setItem: function(key, value) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, getWindowOrThrow().localStorage.setItem(key, value)];
          });
        });
      },
      keySync: function(index) {
        return getWindowOrThrow().localStorage.key(index);
      },
      clearSync: function() {
        return getWindowOrThrow().localStorage.clear();
      },
      getItemSync: function(key) {
        return getWindowOrThrow().localStorage.getItem(key);
      },
      removeItemSync: function(key) {
        return getWindowOrThrow().localStorage.removeItem(key);
      },
      setItemSync: function(key, value) {
        return getWindowOrThrow().localStorage.setItem(key, value);
      }
    };
    var defaultSessionStorageHandler = {
      key: function(index) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, getWindowOrThrow().sessionStorage.key(index)];
          });
        });
      },
      clear: function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, getWindowOrThrow().sessionStorage.clear()];
          });
        });
      },
      getItem: function(key) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, getWindowOrThrow().sessionStorage.getItem(key)];
          });
        });
      },
      removeItem: function(key) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, getWindowOrThrow().sessionStorage.removeItem(key)];
          });
        });
      },
      setItem: function(key, value) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, getWindowOrThrow().sessionStorage.setItem(key, value)];
          });
        });
      },
      keySync: function(index) {
        return getWindowOrThrow().sessionStorage.key(index);
      },
      clearSync: function() {
        return getWindowOrThrow().sessionStorage.clear();
      },
      getItemSync: function(key) {
        return getWindowOrThrow().sessionStorage.getItem(key);
      },
      removeItemSync: function(key) {
        return getWindowOrThrow().sessionStorage.removeItem(key);
      },
      setItemSync: function(key, value) {
        return getWindowOrThrow().sessionStorage.setItem(key, value);
      }
    };
    exports.defaultWindowHandlerImplementation = {
      history: {
        replaceState: function(data, unused, url) {
          return getWindowOrThrow().history.replaceState(data, unused, url);
        },
        getState: function() {
          return getWindowOrThrow().history.state;
        }
      },
      location: {
        getHref: function() {
          return getWindowOrThrow().location.href;
        },
        setHref: function(href) {
          getWindowOrThrow().location.href = href;
        },
        getSearch: function() {
          return getWindowOrThrow().location.search;
        },
        getHash: function() {
          return getWindowOrThrow().location.hash;
        },
        getPathName: function() {
          return getWindowOrThrow().location.pathname;
        },
        assign: function(url) {
          getWindowOrThrow().location.assign(url);
        },
        getHostName: function() {
          return getWindowOrThrow().location.hostname;
        },
        getHost: function() {
          return getWindowOrThrow().location.host;
        },
        getOrigin: function() {
          return getWindowOrThrow().location.origin;
        }
      },
      getDocument: function() {
        return getWindowOrThrow().document;
      },
      getWindowUnsafe: function() {
        return getWindowOrThrow().window;
      },
      localStorage: defaultLocalStorageHandler,
      sessionStorage: defaultSessionStorageHandler
    };
  }
});

// node_modules/supertokens-website/lib/build/utils/windowHandler/index.js
var require_windowHandler = __commonJS({
  "node_modules/supertokens-website/lib/build/utils/windowHandler/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WindowHandlerReference = void 0;
    var defaultImplementation_1 = require_defaultImplementation();
    var WindowHandlerReference = function() {
      function WindowHandlerReference2(windowHandlerInput) {
        var windowHandlerFunc = function(original) {
          return original;
        };
        if (windowHandlerInput !== void 0) {
          windowHandlerFunc = windowHandlerInput;
        }
        this.windowHandler = windowHandlerFunc(defaultImplementation_1.defaultWindowHandlerImplementation);
      }
      WindowHandlerReference2.init = function(windowHandlerInput) {
        if (WindowHandlerReference2.instance !== void 0) {
          return;
        }
        WindowHandlerReference2.instance = new WindowHandlerReference2(windowHandlerInput);
      };
      WindowHandlerReference2.getReferenceOrThrow = function() {
        if (WindowHandlerReference2.instance === void 0) {
          throw new Error("SuperTokensWindowHandler must be initialized before calling this method.");
        }
        return WindowHandlerReference2.instance;
      };
      return WindowHandlerReference2;
    }();
    exports.WindowHandlerReference = WindowHandlerReference;
    exports.default = WindowHandlerReference;
  }
});

// node_modules/supertokens-website/utils/windowHandler/index.js
var require_windowHandler2 = __commonJS({
  "node_modules/supertokens-website/utils/windowHandler/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    __export(require_windowHandler());
  }
});

// node_modules/supertokens-web-js/lib/build/windowHandler/index.js
var require_windowHandler3 = __commonJS({
  "node_modules/supertokens-web-js/lib/build/windowHandler/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WindowHandlerReference = void 0;
    var windowHandler_1 = require_windowHandler2();
    Object.defineProperty(exports, "WindowHandlerReference", {
      enumerable: true,
      get: function() {
        return windowHandler_1.WindowHandlerReference;
      }
    });
  }
});

// node_modules/supertokens-web-js/lib/build/constants.js
var require_constants = __commonJS({
  "node_modules/supertokens-web-js/lib/build/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SSR_ERROR = exports.DEFAULT_API_BASE_PATH = void 0;
    exports.DEFAULT_API_BASE_PATH = "/auth";
    exports.SSR_ERROR = "\nIf you are trying to use this method doing server-side-rendering, please make sure you move this method inside a componentDidMount method or useEffect hook.";
  }
});

// node_modules/supertokens-web-js/lib/build/normalisedURLDomain.js
var require_normalisedURLDomain = __commonJS({
  "node_modules/supertokens-web-js/lib/build/normalisedURLDomain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NormalisedURLDomain = function() {
      function NormalisedURLDomain2(url) {
        var _this = this;
        this.getAsStringDangerous = function() {
          return _this.value;
        };
        this.value = normaliseURLDomainOrThrowError(url);
      }
      return NormalisedURLDomain2;
    }();
    exports.default = NormalisedURLDomain;
    function normaliseURLDomainOrThrowError(input, ignoreProtocol) {
      if (ignoreProtocol === void 0) {
        ignoreProtocol = false;
      }
      function isAnIpAddress(ipaddress) {
        return /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(
          ipaddress
        );
      }
      input = input.trim();
      try {
        if (!input.startsWith("http://") && !input.startsWith("https://")) {
          throw new Error("Error converting to proper URL");
        }
        var urlObj = new URL(input);
        if (ignoreProtocol) {
          if (urlObj.hostname.startsWith("localhost") || isAnIpAddress(urlObj.hostname)) {
            input = "http://" + urlObj.host;
          } else {
            input = "https://" + urlObj.host;
          }
        } else {
          input = urlObj.protocol + "//" + urlObj.host;
        }
        return input;
      } catch (err) {
      }
      if (input.startsWith("/")) {
        throw new Error("Please provide a valid domain name");
      }
      if (input.indexOf(".") === 0) {
        input = input.substr(1);
      }
      if ((input.indexOf(".") !== -1 || input.startsWith("localhost")) && !input.startsWith("http://") && !input.startsWith("https://")) {
        input = "https://" + input;
        try {
          new URL(input);
          return normaliseURLDomainOrThrowError(input, true);
        } catch (err) {
        }
      }
      throw new Error("Please provide a valid domain name");
    }
  }
});

// node_modules/supertokens-website/lib/build/normalisedURLDomain.js
var require_normalisedURLDomain2 = __commonJS({
  "node_modules/supertokens-website/lib/build/normalisedURLDomain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAnIpAddress = void 0;
    function isAnIpAddress(ipaddress) {
      return /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(
        ipaddress
      );
    }
    exports.isAnIpAddress = isAnIpAddress;
    var NormalisedURLDomain = function() {
      function NormalisedURLDomain2(url) {
        var _this = this;
        this.getAsStringDangerous = function() {
          return _this.value;
        };
        this.value = normaliseURLDomainOrThrowError(url);
      }
      return NormalisedURLDomain2;
    }();
    exports.default = NormalisedURLDomain;
    function normaliseURLDomainOrThrowError(input, ignoreProtocol) {
      if (ignoreProtocol === void 0) {
        ignoreProtocol = false;
      }
      input = input.trim();
      try {
        if (!input.startsWith("http://") && !input.startsWith("https://")) {
          throw new Error("converting to proper URL");
        }
        var urlObj = new URL(input);
        if (ignoreProtocol) {
          if (urlObj.hostname.startsWith("localhost") || isAnIpAddress(urlObj.hostname)) {
            input = "http://" + urlObj.host;
          } else {
            input = "https://" + urlObj.host;
          }
        } else {
          input = urlObj.protocol + "//" + urlObj.host;
        }
        return input;
      } catch (err) {
      }
      if (input.startsWith("/")) {
        throw new Error("Please provide a valid domain name");
      }
      if (input.indexOf(".") === 0) {
        input = input.substr(1);
      }
      if ((input.indexOf(".") !== -1 || input.startsWith("localhost")) && !input.startsWith("http://") && !input.startsWith("https://")) {
        input = "https://" + input;
        try {
          new URL(input);
          return normaliseURLDomainOrThrowError(input, true);
        } catch (err) {
        }
      }
      throw new Error("Please provide a valid domain name");
    }
  }
});

// node_modules/supertokens-website/lib/build/normalisedURLPath.js
var require_normalisedURLPath2 = __commonJS({
  "node_modules/supertokens-website/lib/build/normalisedURLPath.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NormalisedURLPath = function() {
      function NormalisedURLPath2(url) {
        var _this = this;
        this.startsWith = function(other) {
          return _this.value.startsWith(other.value);
        };
        this.appendPath = function(other) {
          return new NormalisedURLPath2(_this.value + other.value);
        };
        this.getAsStringDangerous = function() {
          return _this.value;
        };
        this.value = normaliseURLPathOrThrowError(url);
      }
      return NormalisedURLPath2;
    }();
    exports.default = NormalisedURLPath;
    function normaliseURLPathOrThrowError(input) {
      input = input.trim();
      try {
        if (!input.startsWith("http://") && !input.startsWith("https://")) {
          throw new Error("converting to proper URL");
        }
        var urlObj = new URL(input);
        input = urlObj.pathname;
        if (input.charAt(input.length - 1) === "/") {
          return input.substr(0, input.length - 1);
        }
        return input;
      } catch (err) {
      }
      if ((domainGiven(input) || input.startsWith("localhost")) && !input.startsWith("http://") && !input.startsWith("https://")) {
        input = "http://" + input;
        return normaliseURLPathOrThrowError(input);
      }
      if (input.charAt(0) !== "/") {
        input = "/" + input;
      }
      try {
        new URL("http://example.com" + input);
        return normaliseURLPathOrThrowError("http://example.com" + input);
      } catch (err) {
        throw new Error("Please provide a valid URL path");
      }
    }
    function domainGiven(input) {
      if (input.indexOf(".") === -1 || input.startsWith("/")) {
        return false;
      }
      try {
        var url = new URL(input);
        return url.hostname.indexOf(".") !== -1;
      } catch (e) {
      }
      try {
        var url = new URL("http://" + input);
        return url.hostname.indexOf(".") !== -1;
      } catch (e) {
      }
      return false;
    }
  }
});

// node_modules/supertokens-website/lib/build/version.js
var require_version = __commonJS({
  "node_modules/supertokens-website/lib/build/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.supported_fdi = exports.package_version = void 0;
    exports.package_version = "17.0.2";
    exports.supported_fdi = ["1.16", "1.17"];
  }
});

// node_modules/supertokens-website/lib/build/logger.js
var require_logger = __commonJS({
  "node_modules/supertokens-website/lib/build/logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logDebugMessage = exports.disableLogging = exports.enableLogging = void 0;
    var version_1 = require_version();
    var SUPERTOKENS_DEBUG_NAMESPACE = "com.supertokens";
    var __supertokensWebsiteLogging = false;
    function enableLogging() {
      __supertokensWebsiteLogging = true;
    }
    exports.enableLogging = enableLogging;
    function disableLogging() {
      __supertokensWebsiteLogging = false;
    }
    exports.disableLogging = disableLogging;
    function logDebugMessage(message) {
      if (__supertokensWebsiteLogging) {
        console.log(
          "".concat(SUPERTOKENS_DEBUG_NAMESPACE, ' {t: "').concat(new Date().toISOString(), '", message: "').concat(message, '", supertokens-website-ver: "').concat(version_1.package_version, '"}')
        );
      }
    }
    exports.logDebugMessage = logDebugMessage;
  }
});

// node_modules/supertokens-website/lib/build/utils/index.js
var require_utils = __commonJS({
  "node_modules/supertokens-website/lib/build/utils/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNormalisedUserContext = exports.validateAndNormaliseInputOrThrowError = exports.normaliseSessionScopeOrThrowError = exports.normaliseURLPathOrThrowError = exports.normaliseURLDomainOrThrowError = void 0;
    var normalisedURLDomain_1 = require_normalisedURLDomain2();
    var normalisedURLPath_1 = require_normalisedURLPath2();
    var windowHandler_1 = require_windowHandler();
    var logger_1 = require_logger();
    function normaliseURLDomainOrThrowError(input) {
      var str = new normalisedURLDomain_1.default(input).getAsStringDangerous();
      return str;
    }
    exports.normaliseURLDomainOrThrowError = normaliseURLDomainOrThrowError;
    function normaliseURLPathOrThrowError(input) {
      return new normalisedURLPath_1.default(input).getAsStringDangerous();
    }
    exports.normaliseURLPathOrThrowError = normaliseURLPathOrThrowError;
    function normaliseSessionScopeOrThrowError(sessionTokenFrontendDomain) {
      function helper(sessionTokenFrontendDomain2) {
        sessionTokenFrontendDomain2 = sessionTokenFrontendDomain2.trim().toLowerCase();
        if (sessionTokenFrontendDomain2.startsWith(".")) {
          sessionTokenFrontendDomain2 = sessionTokenFrontendDomain2.substr(1);
        }
        if (!sessionTokenFrontendDomain2.startsWith("http://") && !sessionTokenFrontendDomain2.startsWith("https://")) {
          sessionTokenFrontendDomain2 = "http://" + sessionTokenFrontendDomain2;
        }
        try {
          var urlObj = new URL(sessionTokenFrontendDomain2);
          sessionTokenFrontendDomain2 = urlObj.hostname;
          if (sessionTokenFrontendDomain2.startsWith(".")) {
            sessionTokenFrontendDomain2 = sessionTokenFrontendDomain2.substr(1);
          }
          return sessionTokenFrontendDomain2;
        } catch (err) {
          throw new Error("Please provide a valid sessionTokenFrontendDomain");
        }
      }
      var noDotNormalised = helper(sessionTokenFrontendDomain);
      if (noDotNormalised === "localhost" || (0, normalisedURLDomain_1.isAnIpAddress)(noDotNormalised)) {
        return noDotNormalised;
      }
      if (sessionTokenFrontendDomain.startsWith(".")) {
        return "." + noDotNormalised;
      }
      return noDotNormalised;
    }
    exports.normaliseSessionScopeOrThrowError = normaliseSessionScopeOrThrowError;
    function validateAndNormaliseInputOrThrowError(options) {
      var _this = this;
      var apiDomain = normaliseURLDomainOrThrowError(options.apiDomain);
      var apiBasePath = normaliseURLPathOrThrowError("/auth");
      if (options.apiBasePath !== void 0) {
        apiBasePath = normaliseURLPathOrThrowError(options.apiBasePath);
      }
      var defaultSessionScope = windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getHostName();
      var sessionTokenFrontendDomain = normaliseSessionScopeOrThrowError(
        options !== void 0 && options.sessionTokenFrontendDomain !== void 0 ? options.sessionTokenFrontendDomain : defaultSessionScope
      );
      var sessionExpiredStatusCode = 401;
      if (options.sessionExpiredStatusCode !== void 0) {
        sessionExpiredStatusCode = options.sessionExpiredStatusCode;
      }
      var invalidClaimStatusCode = 403;
      if (options.invalidClaimStatusCode !== void 0) {
        invalidClaimStatusCode = options.invalidClaimStatusCode;
      }
      if (sessionExpiredStatusCode === invalidClaimStatusCode) {
        throw new Error("sessionExpiredStatusCode and invalidClaimStatusCode cannot be the same.");
      }
      var autoAddCredentials = true;
      if (options.autoAddCredentials !== void 0) {
        autoAddCredentials = options.autoAddCredentials;
      }
      var isInIframe = false;
      if (options.isInIframe !== void 0) {
        isInIframe = options.isInIframe;
      }
      var sessionTokenBackendDomain = void 0;
      if (options.sessionTokenBackendDomain !== void 0) {
        sessionTokenBackendDomain = normaliseSessionScopeOrThrowError(options.sessionTokenBackendDomain);
      }
      var preAPIHook = function(context) {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, { url: context.url, requestInit: context.requestInit }];
          });
        });
      };
      if (options.preAPIHook !== void 0) {
        preAPIHook = options.preAPIHook;
      }
      var postAPIHook = function() {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2];
          });
        });
      };
      if (options.postAPIHook !== void 0) {
        postAPIHook = options.postAPIHook;
      }
      var onHandleEvent = function() {
      };
      if (options.onHandleEvent !== void 0) {
        onHandleEvent = options.onHandleEvent;
      }
      var override = __assign(
        {
          functions: function(oI) {
            return oI;
          }
        },
        options.override
      );
      if (options.enableDebugLogs !== void 0 && options.enableDebugLogs) {
        (0, logger_1.enableLogging)();
      }
      return {
        apiDomain,
        apiBasePath,
        sessionTokenFrontendDomain,
        sessionExpiredStatusCode,
        invalidClaimStatusCode,
        autoAddCredentials,
        isInIframe,
        tokenTransferMethod: options.tokenTransferMethod !== void 0 ? options.tokenTransferMethod : "cookie",
        sessionTokenBackendDomain,
        preAPIHook,
        postAPIHook,
        onHandleEvent,
        override
      };
    }
    exports.validateAndNormaliseInputOrThrowError = validateAndNormaliseInputOrThrowError;
    function getNormalisedUserContext(userContext) {
      if (userContext === void 0) {
        return {};
      }
      return userContext;
    }
    exports.getNormalisedUserContext = getNormalisedUserContext;
  }
});

// node_modules/supertokens-website/lib/build/processState.js
var require_processState = __commonJS({
  "node_modules/supertokens-website/lib/build/processState.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProcessState = exports.PROCESS_STATE = void 0;
    var PROCESS_STATE;
    (function(PROCESS_STATE2) {
      PROCESS_STATE2[PROCESS_STATE2["CALLING_INTERCEPTION_REQUEST"] = 0] = "CALLING_INTERCEPTION_REQUEST";
      PROCESS_STATE2[PROCESS_STATE2["CALLING_INTERCEPTION_RESPONSE"] = 1] = "CALLING_INTERCEPTION_RESPONSE";
    })(PROCESS_STATE = exports.PROCESS_STATE || (exports.PROCESS_STATE = {}));
    var ProcessState = function() {
      function ProcessState2() {
        var _this = this;
        this.history = [];
        this.addState = function(state) {
          try {
            if (process !== void 0 && process.env !== void 0 && process.env.TEST_MODE === "testing") {
              _this.history.push(state);
            }
          } catch (ignored) {
          }
        };
        this.getEventByLastEventByName = function(state) {
          for (var i = _this.history.length - 1; i >= 0; i--) {
            if (_this.history[i] == state) {
              return _this.history[i];
            }
          }
          return void 0;
        };
        this.reset = function() {
          _this.history = [];
        };
        this.waitForEvent = function(state, timeInMS) {
          if (timeInMS === void 0) {
            timeInMS = 7e3;
          }
          return __awaiter(_this, void 0, void 0, function() {
            var startTime;
            var _this2 = this;
            return __generator(this, function(_a) {
              startTime = Date.now();
              return [
                2,
                new Promise(function(resolve) {
                  var actualThis = _this2;
                  function tryAndGet() {
                    var result = actualThis.getEventByLastEventByName(state);
                    if (result === void 0) {
                      if (Date.now() - startTime > timeInMS) {
                        resolve(void 0);
                      } else {
                        setTimeout(tryAndGet, 1e3);
                      }
                    } else {
                      resolve(result);
                    }
                  }
                  tryAndGet();
                })
              ];
            });
          });
        };
      }
      ProcessState2.getInstance = function() {
        if (ProcessState2.instance == void 0) {
          ProcessState2.instance = new ProcessState2();
        }
        return ProcessState2.instance;
      };
      return ProcessState2;
    }();
    exports.ProcessState = ProcessState;
  }
});

// node_modules/supertokens-website/lib/build/utils/cookieHandler/defaultImplementation.js
var require_defaultImplementation2 = __commonJS({
  "node_modules/supertokens-website/lib/build/utils/cookieHandler/defaultImplementation.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultCookieHandlerImplementation = void 0;
    var windowHandler_1 = require_windowHandler();
    exports.defaultCookieHandlerImplementation = {
      getCookie: function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [
              2,
              windowHandler_1.default.getReferenceOrThrow().windowHandler.getWindowUnsafe().document.cookie
            ];
          });
        });
      },
      setCookie: function(cookieString) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            windowHandler_1.default.getReferenceOrThrow().windowHandler.getWindowUnsafe().document.cookie = cookieString;
            return [2];
          });
        });
      }
    };
  }
});

// node_modules/supertokens-website/lib/build/utils/cookieHandler/index.js
var require_cookieHandler = __commonJS({
  "node_modules/supertokens-website/lib/build/utils/cookieHandler/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CookieHandlerReference = void 0;
    var defaultImplementation_1 = require_defaultImplementation2();
    var CookieHandlerReference = function() {
      function CookieHandlerReference2(cookieHandlerInput) {
        var cookieHandlerFunc = function(original) {
          return original;
        };
        if (cookieHandlerInput !== void 0) {
          cookieHandlerFunc = cookieHandlerInput;
        }
        this.cookieHandler = cookieHandlerFunc(defaultImplementation_1.defaultCookieHandlerImplementation);
      }
      CookieHandlerReference2.init = function(cookieHandlerInput) {
        if (CookieHandlerReference2.instance !== void 0) {
          return;
        }
        CookieHandlerReference2.instance = new CookieHandlerReference2(cookieHandlerInput);
      };
      CookieHandlerReference2.getReferenceOrThrow = function() {
        if (CookieHandlerReference2.instance === void 0) {
          throw new Error("SuperTokensCookieHandler must be initialized before calling this method.");
        }
        return CookieHandlerReference2.instance;
      };
      return CookieHandlerReference2;
    }();
    exports.CookieHandlerReference = CookieHandlerReference;
    exports.default = CookieHandlerReference;
  }
});

// node_modules/browser-tabs-lock/processLock.js
var require_processLock = __commonJS({
  "node_modules/browser-tabs-lock/processLock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProcessLocking = function() {
      function ProcessLocking2() {
        var _this = this;
        this.locked = /* @__PURE__ */ new Map();
        this.addToLocked = function(key, toAdd) {
          var callbacks = _this.locked.get(key);
          if (callbacks === void 0) {
            if (toAdd === void 0) {
              _this.locked.set(key, []);
            } else {
              _this.locked.set(key, [toAdd]);
            }
          } else {
            if (toAdd !== void 0) {
              callbacks.unshift(toAdd);
              _this.locked.set(key, callbacks);
            }
          }
        };
        this.isLocked = function(key) {
          return _this.locked.has(key);
        };
        this.lock = function(key) {
          return new Promise(function(resolve, reject) {
            if (_this.isLocked(key)) {
              _this.addToLocked(key, resolve);
            } else {
              _this.addToLocked(key);
              resolve();
            }
          });
        };
        this.unlock = function(key) {
          var callbacks = _this.locked.get(key);
          if (callbacks === void 0 || callbacks.length === 0) {
            _this.locked.delete(key);
            return;
          }
          var toCall = callbacks.pop();
          _this.locked.set(key, callbacks);
          if (toCall !== void 0) {
            setTimeout(toCall, 0);
          }
        };
      }
      ProcessLocking2.getInstance = function() {
        if (ProcessLocking2.instance === void 0) {
          ProcessLocking2.instance = new ProcessLocking2();
        }
        return ProcessLocking2.instance;
      };
      return ProcessLocking2;
    }();
    function getLock() {
      return ProcessLocking.getInstance();
    }
    exports.default = getLock;
  }
});

// node_modules/browser-tabs-lock/index.js
var require_browser_tabs_lock = __commonJS({
  "node_modules/browser-tabs-lock/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : new P(function(resolve2) {
            resolve2(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var _this = exports;
    Object.defineProperty(exports, "__esModule", { value: true });
    var processLock_1 = require_processLock();
    var LOCK_STORAGE_KEY = "browser-tabs-lock-key";
    var DEFAULT_STORAGE_HANDLER = {
      key: function(index) {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            throw new Error("Unsupported");
          });
        });
      },
      getItem: function(key) {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            throw new Error("Unsupported");
          });
        });
      },
      clear: function() {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, window.localStorage.clear()];
          });
        });
      },
      removeItem: function(key) {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            throw new Error("Unsupported");
          });
        });
      },
      setItem: function(key, value) {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            throw new Error("Unsupported");
          });
        });
      },
      keySync: function(index) {
        return window.localStorage.key(index);
      },
      getItemSync: function(key) {
        return window.localStorage.getItem(key);
      },
      clearSync: function() {
        return window.localStorage.clear();
      },
      removeItemSync: function(key) {
        return window.localStorage.removeItem(key);
      },
      setItemSync: function(key, value) {
        return window.localStorage.setItem(key, value);
      }
    };
    function delay(milliseconds) {
      return new Promise(function(resolve) {
        return setTimeout(resolve, milliseconds);
      });
    }
    function generateRandomString(length) {
      var CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
      var randomstring = "";
      for (var i = 0; i < length; i++) {
        var INDEX = Math.floor(Math.random() * CHARS.length);
        randomstring += CHARS[INDEX];
      }
      return randomstring;
    }
    function getLockId() {
      return Date.now().toString() + generateRandomString(15);
    }
    var SuperTokensLock = function() {
      function SuperTokensLock2(storageHandler) {
        this.acquiredIatSet = /* @__PURE__ */ new Set();
        this.storageHandler = void 0;
        this.id = getLockId();
        this.acquireLock = this.acquireLock.bind(this);
        this.releaseLock = this.releaseLock.bind(this);
        this.releaseLock__private__ = this.releaseLock__private__.bind(this);
        this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this);
        this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this);
        this.storageHandler = storageHandler;
        if (SuperTokensLock2.waiters === void 0) {
          SuperTokensLock2.waiters = [];
        }
      }
      SuperTokensLock2.prototype.acquireLock = function(lockKey, timeout) {
        if (timeout === void 0) {
          timeout = 5e3;
        }
        return __awaiter(this, void 0, void 0, function() {
          var iat, MAX_TIME, STORAGE_KEY, STORAGE, lockObj, TIMEOUT_KEY, lockObjPostDelay, parsedLockObjPostDelay;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                iat = Date.now() + generateRandomString(4);
                MAX_TIME = Date.now() + timeout;
                STORAGE_KEY = LOCK_STORAGE_KEY + "-" + lockKey;
                STORAGE = this.storageHandler === void 0 ? DEFAULT_STORAGE_HANDLER : this.storageHandler;
                _a.label = 1;
              case 1:
                if (!(Date.now() < MAX_TIME))
                  return [3, 8];
                return [4, delay(30)];
              case 2:
                _a.sent();
                lockObj = STORAGE.getItemSync(STORAGE_KEY);
                if (!(lockObj === null))
                  return [3, 5];
                TIMEOUT_KEY = this.id + "-" + lockKey + "-" + iat;
                return [4, delay(Math.floor(Math.random() * 25))];
              case 3:
                _a.sent();
                STORAGE.setItemSync(STORAGE_KEY, JSON.stringify({
                  id: this.id,
                  iat,
                  timeoutKey: TIMEOUT_KEY,
                  timeAcquired: Date.now(),
                  timeRefreshed: Date.now()
                }));
                return [4, delay(30)];
              case 4:
                _a.sent();
                lockObjPostDelay = STORAGE.getItemSync(STORAGE_KEY);
                if (lockObjPostDelay !== null) {
                  parsedLockObjPostDelay = JSON.parse(lockObjPostDelay);
                  if (parsedLockObjPostDelay.id === this.id && parsedLockObjPostDelay.iat === iat) {
                    this.acquiredIatSet.add(iat);
                    this.refreshLockWhileAcquired(STORAGE_KEY, iat);
                    return [2, true];
                  }
                }
                return [3, 7];
              case 5:
                SuperTokensLock2.lockCorrector(this.storageHandler === void 0 ? DEFAULT_STORAGE_HANDLER : this.storageHandler);
                return [4, this.waitForSomethingToChange(MAX_TIME)];
              case 6:
                _a.sent();
                _a.label = 7;
              case 7:
                iat = Date.now() + generateRandomString(4);
                return [3, 1];
              case 8:
                return [2, false];
            }
          });
        });
      };
      SuperTokensLock2.prototype.refreshLockWhileAcquired = function(storageKey, iat) {
        return __awaiter(this, void 0, void 0, function() {
          var _this2 = this;
          return __generator(this, function(_a) {
            setTimeout(function() {
              return __awaiter(_this2, void 0, void 0, function() {
                var STORAGE, lockObj, parsedLockObj;
                return __generator(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      return [4, processLock_1.default().lock(iat)];
                    case 1:
                      _a2.sent();
                      if (!this.acquiredIatSet.has(iat)) {
                        processLock_1.default().unlock(iat);
                        return [2];
                      }
                      STORAGE = this.storageHandler === void 0 ? DEFAULT_STORAGE_HANDLER : this.storageHandler;
                      lockObj = STORAGE.getItemSync(storageKey);
                      if (lockObj !== null) {
                        parsedLockObj = JSON.parse(lockObj);
                        parsedLockObj.timeRefreshed = Date.now();
                        STORAGE.setItemSync(storageKey, JSON.stringify(parsedLockObj));
                        processLock_1.default().unlock(iat);
                      } else {
                        processLock_1.default().unlock(iat);
                        return [2];
                      }
                      this.refreshLockWhileAcquired(storageKey, iat);
                      return [2];
                  }
                });
              });
            }, 1e3);
            return [2];
          });
        });
      };
      SuperTokensLock2.prototype.waitForSomethingToChange = function(MAX_TIME) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, new Promise(function(resolve) {
                  var resolvedCalled = false;
                  var startedAt = Date.now();
                  var MIN_TIME_TO_WAIT = 50;
                  var removedListeners = false;
                  function stopWaiting() {
                    if (!removedListeners) {
                      window.removeEventListener("storage", stopWaiting);
                      SuperTokensLock2.removeFromWaiting(stopWaiting);
                      clearTimeout(timeOutId);
                      removedListeners = true;
                    }
                    if (!resolvedCalled) {
                      resolvedCalled = true;
                      var timeToWait = MIN_TIME_TO_WAIT - (Date.now() - startedAt);
                      if (timeToWait > 0) {
                        setTimeout(resolve, timeToWait);
                      } else {
                        resolve(null);
                      }
                    }
                  }
                  window.addEventListener("storage", stopWaiting);
                  SuperTokensLock2.addToWaiting(stopWaiting);
                  var timeOutId = setTimeout(stopWaiting, Math.max(0, MAX_TIME - Date.now()));
                })];
              case 1:
                _a.sent();
                return [2];
            }
          });
        });
      };
      SuperTokensLock2.addToWaiting = function(func) {
        this.removeFromWaiting(func);
        if (SuperTokensLock2.waiters === void 0) {
          return;
        }
        SuperTokensLock2.waiters.push(func);
      };
      SuperTokensLock2.removeFromWaiting = function(func) {
        if (SuperTokensLock2.waiters === void 0) {
          return;
        }
        SuperTokensLock2.waiters = SuperTokensLock2.waiters.filter(function(i) {
          return i !== func;
        });
      };
      SuperTokensLock2.notifyWaiters = function() {
        if (SuperTokensLock2.waiters === void 0) {
          return;
        }
        var waiters = SuperTokensLock2.waiters.slice();
        waiters.forEach(function(i) {
          return i();
        });
      };
      SuperTokensLock2.prototype.releaseLock = function(lockKey) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.releaseLock__private__(lockKey)];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      SuperTokensLock2.prototype.releaseLock__private__ = function(lockKey) {
        return __awaiter(this, void 0, void 0, function() {
          var STORAGE, STORAGE_KEY, lockObj, parsedlockObj;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                STORAGE = this.storageHandler === void 0 ? DEFAULT_STORAGE_HANDLER : this.storageHandler;
                STORAGE_KEY = LOCK_STORAGE_KEY + "-" + lockKey;
                lockObj = STORAGE.getItemSync(STORAGE_KEY);
                if (lockObj === null) {
                  return [2];
                }
                parsedlockObj = JSON.parse(lockObj);
                if (!(parsedlockObj.id === this.id))
                  return [3, 2];
                return [4, processLock_1.default().lock(parsedlockObj.iat)];
              case 1:
                _a.sent();
                this.acquiredIatSet.delete(parsedlockObj.iat);
                STORAGE.removeItemSync(STORAGE_KEY);
                processLock_1.default().unlock(parsedlockObj.iat);
                SuperTokensLock2.notifyWaiters();
                _a.label = 2;
              case 2:
                return [2];
            }
          });
        });
      };
      SuperTokensLock2.lockCorrector = function(storageHandler) {
        var MIN_ALLOWED_TIME = Date.now() - 5e3;
        var STORAGE = storageHandler;
        var KEYS = [];
        var currIndex = 0;
        while (true) {
          var key = STORAGE.keySync(currIndex);
          if (key === null) {
            break;
          }
          KEYS.push(key);
          currIndex++;
        }
        var notifyWaiters = false;
        for (var i = 0; i < KEYS.length; i++) {
          var LOCK_KEY = KEYS[i];
          if (LOCK_KEY.includes(LOCK_STORAGE_KEY)) {
            var lockObj = STORAGE.getItemSync(LOCK_KEY);
            if (lockObj !== null) {
              var parsedlockObj = JSON.parse(lockObj);
              if (parsedlockObj.timeRefreshed === void 0 && parsedlockObj.timeAcquired < MIN_ALLOWED_TIME || parsedlockObj.timeRefreshed !== void 0 && parsedlockObj.timeRefreshed < MIN_ALLOWED_TIME) {
                STORAGE.removeItemSync(LOCK_KEY);
                notifyWaiters = true;
              }
            }
          }
        }
        if (notifyWaiters) {
          SuperTokensLock2.notifyWaiters();
        }
      };
      SuperTokensLock2.waiters = void 0;
      return SuperTokensLock2;
    }();
    exports.default = SuperTokensLock;
  }
});

// node_modules/supertokens-website/lib/build/utils/lockFactory/index.js
var require_lockFactory = __commonJS({
  "node_modules/supertokens-website/lib/build/utils/lockFactory/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LockFactoryReference = void 0;
    var browser_tabs_lock_1 = require_browser_tabs_lock();
    var defaultFactory = function(storageHandler) {
      return function() {
        return Promise.resolve(new browser_tabs_lock_1.default(storageHandler));
      };
    };
    var LockFactoryReference = function() {
      function LockFactoryReference2(lockFactory) {
        this.lockFactory = lockFactory;
      }
      LockFactoryReference2.init = function(lockFactory, storageHandler) {
        if (this.instance !== void 0) {
          return;
        }
        this.instance = new LockFactoryReference2(
          lockFactory !== null && lockFactory !== void 0 ? lockFactory : defaultFactory(storageHandler)
        );
      };
      LockFactoryReference2.getReferenceOrThrow = function() {
        if (LockFactoryReference2.instance === void 0) {
          throw new Error("SuperTokensLockReference must be initialized before calling this method.");
        }
        return LockFactoryReference2.instance;
      };
      return LockFactoryReference2;
    }();
    exports.LockFactoryReference = LockFactoryReference;
    exports.default = LockFactoryReference;
  }
});

// node_modules/supertokens-website/lib/build/fetch.js
var require_fetch = __commonJS({
  "node_modules/supertokens-website/lib/build/fetch.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fireSessionUpdateEventsIfNecessary = exports.setFrontToken = exports.getFrontToken = exports.setAntiCSRF = exports.saveLastAccessTokenUpdate = exports.getTokenForHeaderAuth = exports.setToken = exports.getStorageNameForToken = exports.getLocalSessionState = exports.onInvalidClaimResponse = exports.onTokenUpdate = exports.onUnauthorisedResponse = exports.FrontToken = exports.AntiCsrfToken = void 0;
    var processState_1 = require_processState();
    var version_1 = require_version();
    var cookieHandler_1 = require_cookieHandler();
    var windowHandler_1 = require_windowHandler();
    var lockFactory_1 = require_lockFactory();
    var logger_1 = require_logger();
    var AntiCsrfToken = function() {
      function AntiCsrfToken2() {
      }
      AntiCsrfToken2.getToken = function(associatedAccessTokenUpdate) {
        return __awaiter(this, void 0, void 0, function() {
          var antiCsrf;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                (0, logger_1.logDebugMessage)("AntiCsrfToken.getToken: called");
                if (associatedAccessTokenUpdate === void 0) {
                  AntiCsrfToken2.tokenInfo = void 0;
                  (0, logger_1.logDebugMessage)("AntiCsrfToken.getToken: returning undefined");
                  return [2, void 0];
                }
                if (!(AntiCsrfToken2.tokenInfo === void 0))
                  return [3, 2];
                return [4, getAntiCSRFToken()];
              case 1:
                antiCsrf = _a.sent();
                if (antiCsrf === null) {
                  (0, logger_1.logDebugMessage)("AntiCsrfToken.getToken: returning undefined");
                  return [2, void 0];
                }
                AntiCsrfToken2.tokenInfo = {
                  antiCsrf,
                  associatedAccessTokenUpdate
                };
                return [3, 4];
              case 2:
                if (!(AntiCsrfToken2.tokenInfo.associatedAccessTokenUpdate !== associatedAccessTokenUpdate))
                  return [3, 4];
                AntiCsrfToken2.tokenInfo = void 0;
                return [4, AntiCsrfToken2.getToken(associatedAccessTokenUpdate)];
              case 3:
                return [2, _a.sent()];
              case 4:
                (0, logger_1.logDebugMessage)("AntiCsrfToken.getToken: returning: " + AntiCsrfToken2.tokenInfo.antiCsrf);
                return [2, AntiCsrfToken2.tokenInfo.antiCsrf];
            }
          });
        });
      };
      AntiCsrfToken2.removeToken = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                (0, logger_1.logDebugMessage)("AntiCsrfToken.removeToken: called");
                AntiCsrfToken2.tokenInfo = void 0;
                return [4, setAntiCSRF(void 0)];
              case 1:
                _a.sent();
                return [2];
            }
          });
        });
      };
      AntiCsrfToken2.setItem = function(associatedAccessTokenUpdate, antiCsrf) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (associatedAccessTokenUpdate === void 0) {
                  AntiCsrfToken2.tokenInfo = void 0;
                  return [2];
                }
                (0, logger_1.logDebugMessage)("AntiCsrfToken.setItem: called");
                return [4, setAntiCSRF(antiCsrf)];
              case 1:
                _a.sent();
                AntiCsrfToken2.tokenInfo = {
                  antiCsrf,
                  associatedAccessTokenUpdate
                };
                return [2];
            }
          });
        });
      };
      return AntiCsrfToken2;
    }();
    exports.AntiCsrfToken = AntiCsrfToken;
    var FrontToken = function() {
      function FrontToken2() {
      }
      FrontToken2.getTokenInfo = function() {
        return __awaiter(this, void 0, void 0, function() {
          var frontToken, response;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                (0, logger_1.logDebugMessage)("FrontToken.getTokenInfo: called");
                return [4, getFrontToken()];
              case 1:
                frontToken = _a.sent();
                if (!(frontToken === null))
                  return [3, 5];
                return [4, getLocalSessionState(false)];
              case 2:
                if (!(_a.sent().status === "EXISTS"))
                  return [3, 4];
                return [
                  4,
                  new Promise(function(resolve) {
                    FrontToken2.waiters.push(resolve);
                  })
                ];
              case 3:
                _a.sent();
                return [2, FrontToken2.getTokenInfo()];
              case 4:
                return [2, void 0];
              case 5:
                response = parseFrontToken(frontToken);
                (0, logger_1.logDebugMessage)("FrontToken.getTokenInfo: returning ate: " + response.ate);
                (0, logger_1.logDebugMessage)("FrontToken.getTokenInfo: returning uid: " + response.uid);
                (0, logger_1.logDebugMessage)("FrontToken.getTokenInfo: returning up: " + response.up);
                return [2, response];
            }
          });
        });
      };
      FrontToken2.removeToken = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                (0, logger_1.logDebugMessage)("FrontToken.removeToken: called");
                return [4, setFrontToken(void 0)];
              case 1:
                _a.sent();
                return [4, setToken("access", "")];
              case 2:
                _a.sent();
                return [4, setToken("refresh", "")];
              case 3:
                _a.sent();
                FrontToken2.waiters.forEach(function(f) {
                  return f(void 0);
                });
                FrontToken2.waiters = [];
                return [2];
            }
          });
        });
      };
      FrontToken2.setItem = function(frontToken) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, saveLastAccessTokenUpdate()];
              case 1:
                _a.sent();
                if (frontToken === "remove") {
                  return [2, FrontToken2.removeToken()];
                }
                (0, logger_1.logDebugMessage)("FrontToken.setItem: called");
                return [4, setFrontToken(frontToken)];
              case 2:
                _a.sent();
                FrontToken2.waiters.forEach(function(f) {
                  return f(void 0);
                });
                FrontToken2.waiters = [];
                return [2];
            }
          });
        });
      };
      FrontToken2.doesTokenExists = function() {
        return __awaiter(this, void 0, void 0, function() {
          var frontToken;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, getFrontTokenFromCookie()];
              case 1:
                frontToken = _a.sent();
                return [2, frontToken !== null];
            }
          });
        });
      };
      FrontToken2.waiters = [];
      return FrontToken2;
    }();
    exports.FrontToken = FrontToken;
    var AuthHttpRequest = function() {
      function AuthHttpRequest2() {
      }
      AuthHttpRequest2.init = function(config, recipeImpl) {
        (0, logger_1.logDebugMessage)("init: called");
        (0, logger_1.logDebugMessage)("init: Input apiBasePath: " + config.apiBasePath);
        (0, logger_1.logDebugMessage)("init: Input apiDomain: " + config.apiDomain);
        (0, logger_1.logDebugMessage)("init: Input autoAddCredentials: " + config.autoAddCredentials);
        (0, logger_1.logDebugMessage)("init: Input sessionTokenBackendDomain: " + config.sessionTokenBackendDomain);
        (0, logger_1.logDebugMessage)("init: Input isInIframe: " + config.isInIframe);
        (0, logger_1.logDebugMessage)("init: Input sessionExpiredStatusCode: " + config.sessionExpiredStatusCode);
        (0, logger_1.logDebugMessage)("init: Input sessionTokenFrontendDomain: " + config.sessionTokenFrontendDomain);
        (0, logger_1.logDebugMessage)("init: Input tokenTransferMethod: " + config.tokenTransferMethod);
        var fetchedWindow = windowHandler_1.default.getReferenceOrThrow().windowHandler.getWindowUnsafe();
        AuthHttpRequest2.env = fetchedWindow === void 0 || fetchedWindow.fetch === void 0 ? global : fetchedWindow;
        AuthHttpRequest2.refreshTokenUrl = config.apiDomain + config.apiBasePath + "/session/refresh";
        AuthHttpRequest2.signOutUrl = config.apiDomain + config.apiBasePath + "/signout";
        AuthHttpRequest2.rid = "session";
        AuthHttpRequest2.config = config;
        if (AuthHttpRequest2.env.__supertokensOriginalFetch === void 0) {
          (0, logger_1.logDebugMessage)("init: __supertokensOriginalFetch is undefined");
          AuthHttpRequest2.env.__supertokensOriginalFetch = AuthHttpRequest2.env.fetch.bind(AuthHttpRequest2.env);
          AuthHttpRequest2.env.__supertokensSessionRecipe = recipeImpl;
          AuthHttpRequest2.env.fetch = AuthHttpRequest2.env.__supertokensSessionRecipe.addFetchInterceptorsAndReturnModifiedFetch({
            originalFetch: AuthHttpRequest2.env.__supertokensOriginalFetch,
            userContext: {}
          });
          AuthHttpRequest2.env.__supertokensSessionRecipe.addXMLHttpRequestInterceptor({
            userContext: {}
          });
        }
        AuthHttpRequest2.recipeImpl = AuthHttpRequest2.env.__supertokensSessionRecipe;
        AuthHttpRequest2.initCalled = true;
      };
      var _a;
      _a = AuthHttpRequest2;
      AuthHttpRequest2.initCalled = false;
      AuthHttpRequest2.doRequest = function(httpCall, config, url) {
        return __awaiter(void 0, void 0, void 0, function() {
          var doNotDoInterception, finalURL, origHeaders, accessToken, refreshToken, returnObj, preRequestLSS, clonedHeaders, configWithAntiCsrf, antiCsrfToken, transferMethod, response, retry, postRequestIdToken;
          return __generator(_a, function(_b) {
            switch (_b.label) {
              case 0:
                if (!AuthHttpRequest2.initCalled) {
                  throw Error("init function not called");
                }
                (0, logger_1.logDebugMessage)("doRequest: start of fetch interception");
                doNotDoInterception = false;
                try {
                  finalURL = void 0;
                  if (typeof url === "string") {
                    finalURL = url;
                  } else if (typeof url === "object") {
                    if (typeof url.url === "string") {
                      finalURL = url.url;
                    } else if (typeof url.href === "string") {
                      finalURL = url.href;
                    }
                  }
                  doNotDoInterception = !AuthHttpRequest2.recipeImpl.shouldDoInterceptionBasedOnUrl(
                    finalURL,
                    AuthHttpRequest2.config.apiDomain,
                    AuthHttpRequest2.config.sessionTokenBackendDomain
                  );
                } catch (err) {
                  if (err.message === "Please provide a valid domain name") {
                    (0, logger_1.logDebugMessage)(
                      "doRequest: Trying shouldDoInterceptionBasedOnUrl with location.origin"
                    );
                    doNotDoInterception = !AuthHttpRequest2.recipeImpl.shouldDoInterceptionBasedOnUrl(
                      windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(),
                      AuthHttpRequest2.config.apiDomain,
                      AuthHttpRequest2.config.sessionTokenBackendDomain
                    );
                  } else {
                    throw err;
                  }
                }
                (0, logger_1.logDebugMessage)("doRequest: Value of doNotDoInterception: " + doNotDoInterception);
                if (!doNotDoInterception)
                  return [3, 2];
                (0, logger_1.logDebugMessage)("doRequest: Returning without interception");
                return [4, httpCall(config)];
              case 1:
                return [2, _b.sent()];
              case 2:
                origHeaders = new Headers(
                  config !== void 0 && config.headers !== void 0 ? config.headers : url.headers
                );
                if (!origHeaders.has("Authorization"))
                  return [3, 5];
                return [4, getTokenForHeaderAuth("access")];
              case 3:
                accessToken = _b.sent();
                return [4, getTokenForHeaderAuth("refresh")];
              case 4:
                refreshToken = _b.sent();
                if (accessToken !== void 0 && refreshToken !== void 0 && origHeaders.get("Authorization") === "Bearer ".concat(accessToken)) {
                  (0, logger_1.logDebugMessage)(
                    "doRequest: Removing Authorization from user provided headers because it contains our access token"
                  );
                  origHeaders.delete("Authorization");
                }
                _b.label = 5;
              case 5:
                (0, logger_1.logDebugMessage)("doRequest: Interception started");
                processState_1.ProcessState.getInstance().addState(
                  processState_1.PROCESS_STATE.CALLING_INTERCEPTION_REQUEST
                );
                _b.label = 6;
              case 6:
                _b.trys.push([6, , 20, 25]);
                returnObj = void 0;
                _b.label = 7;
              case 7:
                if (false)
                  return [3, 19];
                return [4, getLocalSessionState(true)];
              case 8:
                preRequestLSS = _b.sent();
                clonedHeaders = new Headers(origHeaders);
                configWithAntiCsrf = __assign(__assign({}, config), { headers: clonedHeaders });
                if (!(preRequestLSS.status === "EXISTS"))
                  return [3, 10];
                return [4, AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)];
              case 9:
                antiCsrfToken = _b.sent();
                if (antiCsrfToken !== void 0) {
                  (0, logger_1.logDebugMessage)("doRequest: Adding anti-csrf token to request");
                  clonedHeaders.set("anti-csrf", antiCsrfToken);
                }
                _b.label = 10;
              case 10:
                if (AuthHttpRequest2.config.autoAddCredentials) {
                  (0, logger_1.logDebugMessage)("doRequest: Adding credentials include");
                  if (configWithAntiCsrf === void 0) {
                    configWithAntiCsrf = {
                      credentials: "include"
                    };
                  } else if (configWithAntiCsrf.credentials === void 0) {
                    configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {
                      credentials: "include"
                    });
                  }
                }
                if (!clonedHeaders.has("rid")) {
                  (0, logger_1.logDebugMessage)("doRequest: Adding rid header: anti-csrf");
                  clonedHeaders.set("rid", "anti-csrf");
                } else {
                  (0, logger_1.logDebugMessage)("doRequest: rid header was already there in request");
                }
                transferMethod = AuthHttpRequest2.config.tokenTransferMethod;
                (0, logger_1.logDebugMessage)("doRequest: Adding st-auth-mode header: " + transferMethod);
                clonedHeaders.set("st-auth-mode", transferMethod);
                return [4, setAuthorizationHeaderIfRequired(clonedHeaders)];
              case 11:
                _b.sent();
                (0, logger_1.logDebugMessage)("doRequest: Making user's http call");
                return [4, httpCall(configWithAntiCsrf)];
              case 12:
                response = _b.sent();
                (0, logger_1.logDebugMessage)("doRequest: User's http call ended");
                return [4, saveTokensFromHeaders(response)];
              case 13:
                _b.sent();
                fireSessionUpdateEventsIfNecessary(
                  preRequestLSS.status === "EXISTS",
                  response.status,
                  response.headers.get("front-token")
                );
                if (!(response.status === AuthHttpRequest2.config.sessionExpiredStatusCode))
                  return [3, 15];
                (0, logger_1.logDebugMessage)("doRequest: Status code is: " + response.status);
                return [4, onUnauthorisedResponse(preRequestLSS)];
              case 14:
                retry = _b.sent();
                if (retry.result !== "RETRY") {
                  (0, logger_1.logDebugMessage)("doRequest: Not retrying original request");
                  returnObj = retry.error !== void 0 ? retry.error : response;
                  return [3, 19];
                }
                (0, logger_1.logDebugMessage)("doRequest: Retrying original request");
                return [3, 18];
              case 15:
                if (!(response.status === AuthHttpRequest2.config.invalidClaimStatusCode))
                  return [3, 17];
                return [4, onInvalidClaimResponse(response)];
              case 16:
                _b.sent();
                _b.label = 17;
              case 17:
                return [2, response];
              case 18:
                return [3, 7];
              case 19:
                return [2, returnObj];
              case 20:
                return [4, getLocalSessionState(false)];
              case 21:
                postRequestIdToken = _b.sent();
                if (!(postRequestIdToken.status === "NOT_EXISTS"))
                  return [3, 24];
                (0, logger_1.logDebugMessage)("doRequest: local session doesn't exist, so removing anti-csrf and sFrontToken");
                return [4, AntiCsrfToken.removeToken()];
              case 22:
                _b.sent();
                return [4, FrontToken.removeToken()];
              case 23:
                _b.sent();
                _b.label = 24;
              case 24:
                return [7];
              case 25:
                return [2];
            }
          });
        });
      };
      AuthHttpRequest2.attemptRefreshingSession = function() {
        return __awaiter(void 0, void 0, void 0, function() {
          var preRequestLSS, refresh;
          return __generator(_a, function(_b) {
            switch (_b.label) {
              case 0:
                if (!AuthHttpRequest2.initCalled) {
                  throw Error("init function not called");
                }
                return [4, getLocalSessionState(false)];
              case 1:
                preRequestLSS = _b.sent();
                return [4, onUnauthorisedResponse(preRequestLSS)];
              case 2:
                refresh = _b.sent();
                if (refresh.result === "API_ERROR") {
                  throw refresh.error;
                }
                return [2, refresh.result === "RETRY"];
            }
          });
        });
      };
      return AuthHttpRequest2;
    }();
    exports.default = AuthHttpRequest;
    var LAST_ACCESS_TOKEN_UPDATE = "st-last-access-token-update";
    var REFRESH_TOKEN_NAME = "st-refresh-token";
    var ACCESS_TOKEN_NAME = "st-access-token";
    var ANTI_CSRF_NAME = "sAntiCsrf";
    var FRONT_TOKEN_NAME = "sFrontToken";
    function onUnauthorisedResponse(preRequestLSS) {
      return __awaiter(this, void 0, void 0, function() {
        var lock, postLockLSS, headers, antiCsrfToken, transferMethod, preAPIResult, response, isUnauthorised, error_1, postRequestLSS;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, lockFactory_1.default.getReferenceOrThrow().lockFactory()];
            case 1:
              lock = _b.sent();
              _b.label = 2;
            case 2:
              if (false)
                return [3, 24];
              (0, logger_1.logDebugMessage)("onUnauthorisedResponse: trying to acquire lock");
              return [4, lock.acquireLock("REFRESH_TOKEN_USE", 1e3)];
            case 3:
              if (!_b.sent())
                return [3, 22];
              (0, logger_1.logDebugMessage)("onUnauthorisedResponse: lock acquired");
              _b.label = 4;
            case 4:
              _b.trys.push([4, 14, 16, 22]);
              return [4, getLocalSessionState(false)];
            case 5:
              postLockLSS = _b.sent();
              if (postLockLSS.status === "NOT_EXISTS") {
                (0, logger_1.logDebugMessage)(
                  "onUnauthorisedResponse: Not refreshing because local session state is NOT_EXISTS"
                );
                AuthHttpRequest.config.onHandleEvent({
                  action: "UNAUTHORISED",
                  sessionExpiredOrRevoked: false,
                  userContext: {}
                });
                return [2, { result: "SESSION_EXPIRED" }];
              }
              if (postLockLSS.status !== preRequestLSS.status || postLockLSS.status === "EXISTS" && preRequestLSS.status === "EXISTS" && postLockLSS.lastAccessTokenUpdate !== preRequestLSS.lastAccessTokenUpdate) {
                (0, logger_1.logDebugMessage)(
                  "onUnauthorisedResponse: Retrying early because pre and post id refresh tokens don't match"
                );
                return [2, { result: "RETRY" }];
              }
              headers = new Headers();
              if (!(preRequestLSS.status === "EXISTS"))
                return [3, 7];
              return [4, AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)];
            case 6:
              antiCsrfToken = _b.sent();
              if (antiCsrfToken !== void 0) {
                (0, logger_1.logDebugMessage)(
                  "onUnauthorisedResponse: Adding anti-csrf token to refresh API call"
                );
                headers.set("anti-csrf", antiCsrfToken);
              }
              _b.label = 7;
            case 7:
              (0, logger_1.logDebugMessage)("onUnauthorisedResponse: Adding rid and fdi-versions to refresh call header");
              headers.set("rid", AuthHttpRequest.rid);
              headers.set("fdi-version", version_1.supported_fdi.join(","));
              transferMethod = AuthHttpRequest.config.tokenTransferMethod;
              (0, logger_1.logDebugMessage)("onUnauthorisedResponse: Adding st-auth-mode header: " + transferMethod);
              headers.set("st-auth-mode", transferMethod);
              return [4, setAuthorizationHeaderIfRequired(headers, true)];
            case 8:
              _b.sent();
              (0, logger_1.logDebugMessage)("onUnauthorisedResponse: Calling refresh pre API hook");
              return [
                4,
                AuthHttpRequest.config.preAPIHook({
                  action: "REFRESH_SESSION",
                  requestInit: {
                    method: "post",
                    credentials: "include",
                    headers
                  },
                  url: AuthHttpRequest.refreshTokenUrl,
                  userContext: {}
                })
              ];
            case 9:
              preAPIResult = _b.sent();
              (0, logger_1.logDebugMessage)("onUnauthorisedResponse: Making refresh call");
              return [
                4,
                AuthHttpRequest.env.__supertokensOriginalFetch(preAPIResult.url, preAPIResult.requestInit)
              ];
            case 10:
              response = _b.sent();
              (0, logger_1.logDebugMessage)("onUnauthorisedResponse: Refresh call ended");
              return [4, saveTokensFromHeaders(response)];
            case 11:
              _b.sent();
              (0, logger_1.logDebugMessage)("onUnauthorisedResponse: Refresh status code is: " + response.status);
              isUnauthorised = response.status === AuthHttpRequest.config.sessionExpiredStatusCode;
              if (isUnauthorised && response.headers.get("front-token") === null) {
                FrontToken.setItem("remove");
              }
              fireSessionUpdateEventsIfNecessary(
                preRequestLSS.status === "EXISTS",
                response.status,
                isUnauthorised && response.headers.get("front-token") === null ? "remove" : response.headers.get("front-token")
              );
              if (response.status >= 300) {
                throw response;
              }
              return [
                4,
                AuthHttpRequest.config.postAPIHook({
                  action: "REFRESH_SESSION",
                  fetchResponse: response.clone(),
                  requestInit: preAPIResult.requestInit,
                  url: preAPIResult.url,
                  userContext: {}
                })
              ];
            case 12:
              _b.sent();
              return [4, getLocalSessionState(false)];
            case 13:
              if (_b.sent().status === "NOT_EXISTS") {
                (0, logger_1.logDebugMessage)(
                  "onUnauthorisedResponse: local session doesn't exist, so returning session expired"
                );
                return [2, { result: "SESSION_EXPIRED" }];
              }
              AuthHttpRequest.config.onHandleEvent({
                action: "REFRESH_SESSION",
                userContext: {}
              });
              (0, logger_1.logDebugMessage)("onUnauthorisedResponse: Sending RETRY signal");
              return [2, { result: "RETRY" }];
            case 14:
              error_1 = _b.sent();
              return [4, getLocalSessionState(false)];
            case 15:
              if (_b.sent().status === "NOT_EXISTS") {
                (0, logger_1.logDebugMessage)(
                  "onUnauthorisedResponse: local session doesn't exist, so returning session expired"
                );
                return [2, { result: "SESSION_EXPIRED", error: error_1 }];
              }
              (0, logger_1.logDebugMessage)("onUnauthorisedResponse: sending API_ERROR");
              return [2, { result: "API_ERROR", error: error_1 }];
            case 16:
              return [4, lock.releaseLock("REFRESH_TOKEN_USE")];
            case 17:
              _b.sent();
              (0, logger_1.logDebugMessage)("onUnauthorisedResponse: Released lock");
              return [4, getLocalSessionState(false)];
            case 18:
              if (!(_b.sent().status === "NOT_EXISTS"))
                return [3, 21];
              (0, logger_1.logDebugMessage)("onUnauthorisedResponse: local session doesn't exist, so removing anti-csrf and sFrontToken");
              return [4, AntiCsrfToken.removeToken()];
            case 19:
              _b.sent();
              return [4, FrontToken.removeToken()];
            case 20:
              _b.sent();
              _b.label = 21;
            case 21:
              return [7];
            case 22:
              return [4, getLocalSessionState(false)];
            case 23:
              postRequestLSS = _b.sent();
              if (postRequestLSS.status === "NOT_EXISTS") {
                (0, logger_1.logDebugMessage)(
                  "onUnauthorisedResponse: lock acquired failed and local session doesn't exist, so sending SESSION_EXPIRED"
                );
                return [2, { result: "SESSION_EXPIRED" }];
              } else {
                if (postRequestLSS.status !== preRequestLSS.status || postRequestLSS.status === "EXISTS" && preRequestLSS.status === "EXISTS" && postRequestLSS.lastAccessTokenUpdate !== preRequestLSS.lastAccessTokenUpdate) {
                  (0, logger_1.logDebugMessage)(
                    "onUnauthorisedResponse: lock acquired failed and retrying early because pre and post id refresh tokens don't match"
                  );
                  return [2, { result: "RETRY" }];
                }
              }
              return [3, 2];
            case 24:
              return [2];
          }
        });
      });
    }
    exports.onUnauthorisedResponse = onUnauthorisedResponse;
    function onTokenUpdate() {
      (0, logger_1.logDebugMessage)("onTokenUpdate: firing ACCESS_TOKEN_PAYLOAD_UPDATED event");
      AuthHttpRequest.config.onHandleEvent({
        action: "ACCESS_TOKEN_PAYLOAD_UPDATED",
        userContext: {}
      });
    }
    exports.onTokenUpdate = onTokenUpdate;
    function onInvalidClaimResponse(response) {
      return __awaiter(this, void 0, void 0, function() {
        var claimValidationErrors, _b;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _c.trys.push([0, 2, , 3]);
              return [
                4,
                AuthHttpRequest.recipeImpl.getInvalidClaimsFromResponse({
                  response,
                  userContext: {}
                })
              ];
            case 1:
              claimValidationErrors = _c.sent();
              if (claimValidationErrors) {
                AuthHttpRequest.config.onHandleEvent({
                  action: "API_INVALID_CLAIM",
                  claimValidationErrors,
                  userContext: {}
                });
              }
              return [3, 3];
            case 2:
              _b = _c.sent();
              return [3, 3];
            case 3:
              return [2];
          }
        });
      });
    }
    exports.onInvalidClaimResponse = onInvalidClaimResponse;
    function getLocalSessionState(tryRefresh) {
      return __awaiter(this, void 0, void 0, function() {
        var lastAccessTokenUpdate, frontTokenExists, response, res;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              (0, logger_1.logDebugMessage)("getLocalSessionState: called");
              return [4, getFromCookies(LAST_ACCESS_TOKEN_UPDATE)];
            case 1:
              lastAccessTokenUpdate = _b.sent();
              return [4, FrontToken.doesTokenExists()];
            case 2:
              frontTokenExists = _b.sent();
              if (!(frontTokenExists && lastAccessTokenUpdate !== void 0))
                return [3, 3];
              (0, logger_1.logDebugMessage)("getLocalSessionState: returning EXISTS since both frontToken and lastAccessTokenUpdate exists");
              return [2, { status: "EXISTS", lastAccessTokenUpdate }];
            case 3:
              if (!lastAccessTokenUpdate)
                return [3, 4];
              (0, logger_1.logDebugMessage)("getLocalSessionState: returning NOT_EXISTS since frontToken was cleared but lastAccessTokenUpdate exists");
              return [2, { status: "NOT_EXISTS" }];
            case 4:
              response = {
                status: "MAY_EXIST"
              };
              if (!tryRefresh)
                return [3, 7];
              (0, logger_1.logDebugMessage)("getLocalSessionState: trying to refresh");
              return [4, onUnauthorisedResponse(response)];
            case 5:
              res = _b.sent();
              if (res.result !== "RETRY") {
                (0, logger_1.logDebugMessage)(
                  "getLocalSessionState: return NOT_EXISTS in case error from backend" + res.result
                );
                return [
                  2,
                  {
                    status: "NOT_EXISTS"
                  }
                ];
              }
              (0, logger_1.logDebugMessage)("getLocalSessionState: Retrying post refresh");
              return [4, getLocalSessionState(tryRefresh)];
            case 6:
              return [2, _b.sent()];
            case 7:
              (0, logger_1.logDebugMessage)("getLocalSessionState: returning: " + response.status);
              return [2, response];
          }
        });
      });
    }
    exports.getLocalSessionState = getLocalSessionState;
    function getStorageNameForToken(tokenType) {
      switch (tokenType) {
        case "access":
          return ACCESS_TOKEN_NAME;
        case "refresh":
          return REFRESH_TOKEN_NAME;
      }
    }
    exports.getStorageNameForToken = getStorageNameForToken;
    function setToken(tokenType, value) {
      var name = getStorageNameForToken(tokenType);
      if (value !== "") {
        (0, logger_1.logDebugMessage)("setToken: saved ".concat(tokenType, " token into cookies"));
        return storeInCookies(name, value, Date.now() + 31536e5);
      } else {
        (0, logger_1.logDebugMessage)("setToken: cleared ".concat(tokenType, " token from cookies"));
        return storeInCookies(name, value, 0);
      }
    }
    exports.setToken = setToken;
    function storeInCookies(name, value, expiry) {
      var expires = "Fri, 31 Dec 9999 23:59:59 GMT";
      if (expiry !== Number.MAX_SAFE_INTEGER) {
        expires = new Date(expiry).toUTCString();
      }
      var domain = AuthHttpRequest.config.sessionTokenFrontendDomain;
      if (domain === "localhost" || domain === windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getHostName()) {
        return cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(
          "".concat(name, "=").concat(value, ";expires=").concat(expires, ";path=/;samesite=").concat(AuthHttpRequest.config.isInIframe ? "none;secure" : "lax")
        );
      } else {
        return cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(
          "".concat(name, "=").concat(value, ";expires=").concat(expires, ";domain=").concat(domain, ";path=/;samesite=").concat(AuthHttpRequest.config.isInIframe ? "none;secure" : "lax")
        );
      }
    }
    function getTokenForHeaderAuth(tokenType) {
      return __awaiter(this, void 0, void 0, function() {
        var name;
        return __generator(this, function(_b) {
          name = getStorageNameForToken(tokenType);
          return [2, getFromCookies(name)];
        });
      });
    }
    exports.getTokenForHeaderAuth = getTokenForHeaderAuth;
    function getFromCookies(name) {
      return __awaiter(this, void 0, void 0, function() {
        var value, _b, parts, last;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _b = "; ";
              return [4, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.getCookie()];
            case 1:
              value = _b + _c.sent();
              parts = value.split("; " + name + "=");
              if (parts.length >= 2) {
                last = parts.pop();
                if (last !== void 0) {
                  return [2, last.split(";").shift()];
                }
              }
              return [2, void 0];
          }
        });
      });
    }
    function setAuthorizationHeaderIfRequired(clonedHeaders, addRefreshToken) {
      if (addRefreshToken === void 0) {
        addRefreshToken = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        var accessToken, refreshToken;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              (0, logger_1.logDebugMessage)("setTokenHeaders: adding existing tokens as header");
              return [4, getTokenForHeaderAuth("access")];
            case 1:
              accessToken = _b.sent();
              return [4, getTokenForHeaderAuth("refresh")];
            case 2:
              refreshToken = _b.sent();
              if ((addRefreshToken || accessToken !== void 0) && refreshToken !== void 0) {
                if (clonedHeaders.has("Authorization")) {
                  (0, logger_1.logDebugMessage)(
                    "setAuthorizationHeaderIfRequired: Authorization header defined by the user, not adding"
                  );
                } else {
                  (0, logger_1.logDebugMessage)(
                    "setAuthorizationHeaderIfRequired: added authorization header"
                  );
                  clonedHeaders.set(
                    "Authorization",
                    "Bearer ".concat(addRefreshToken ? refreshToken : accessToken)
                  );
                }
              } else {
                (0, logger_1.logDebugMessage)(
                  "setAuthorizationHeaderIfRequired: token for header based auth not found"
                );
              }
              return [2];
          }
        });
      });
    }
    function saveTokensFromHeaders(response) {
      return __awaiter(this, void 0, void 0, function() {
        var refreshToken, accessToken, frontToken, antiCsrfToken, tok;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              (0, logger_1.logDebugMessage)("saveTokensFromHeaders: Saving updated tokens from the response headers");
              refreshToken = response.headers.get("st-refresh-token");
              if (!(refreshToken !== null))
                return [3, 2];
              (0, logger_1.logDebugMessage)("saveTokensFromHeaders: saving new refresh token");
              return [4, setToken("refresh", refreshToken)];
            case 1:
              _b.sent();
              _b.label = 2;
            case 2:
              accessToken = response.headers.get("st-access-token");
              if (!(accessToken !== null))
                return [3, 4];
              (0, logger_1.logDebugMessage)("saveTokensFromHeaders: saving new access token");
              return [4, setToken("access", accessToken)];
            case 3:
              _b.sent();
              _b.label = 4;
            case 4:
              frontToken = response.headers.get("front-token");
              if (!(frontToken !== null))
                return [3, 6];
              (0, logger_1.logDebugMessage)("saveTokensFromHeaders: Setting sFrontToken: " + frontToken);
              return [4, FrontToken.setItem(frontToken)];
            case 5:
              _b.sent();
              _b.label = 6;
            case 6:
              antiCsrfToken = response.headers.get("anti-csrf");
              if (!(antiCsrfToken !== null))
                return [3, 9];
              return [4, getLocalSessionState(true)];
            case 7:
              tok = _b.sent();
              if (!(tok.status === "EXISTS"))
                return [3, 9];
              (0, logger_1.logDebugMessage)("saveTokensFromHeaders: Setting anti-csrf token");
              return [4, AntiCsrfToken.setItem(tok.lastAccessTokenUpdate, antiCsrfToken)];
            case 8:
              _b.sent();
              _b.label = 9;
            case 9:
              return [2];
          }
        });
      });
    }
    function saveLastAccessTokenUpdate() {
      return __awaiter(this, void 0, void 0, function() {
        var now;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              (0, logger_1.logDebugMessage)("saveLastAccessTokenUpdate: called");
              now = Date.now().toString();
              (0, logger_1.logDebugMessage)("saveLastAccessTokenUpdate: setting " + now);
              return [4, storeInCookies(LAST_ACCESS_TOKEN_UPDATE, now, Number.MAX_SAFE_INTEGER)];
            case 1:
              _b.sent();
              return [4, storeInCookies("sIRTFrontend", "", 0)];
            case 2:
              _b.sent();
              return [2];
          }
        });
      });
    }
    exports.saveLastAccessTokenUpdate = saveLastAccessTokenUpdate;
    function getAntiCSRFToken() {
      return __awaiter(this, void 0, void 0, function() {
        function getAntiCSRFromCookie() {
          return __awaiter(this, void 0, void 0, function() {
            var value, _b, parts, last, temp;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  _b = "; ";
                  return [
                    4,
                    cookieHandler_1.default.getReferenceOrThrow().cookieHandler.getCookie()
                  ];
                case 1:
                  value = _b + _c.sent();
                  parts = value.split("; " + ANTI_CSRF_NAME + "=");
                  if (parts.length >= 2) {
                    last = parts.pop();
                    if (last !== void 0) {
                      temp = last.split(";").shift();
                      if (temp === void 0) {
                        return [2, null];
                      }
                      return [2, temp];
                    }
                  }
                  return [2, null];
              }
            });
          });
        }
        var fromCookie;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              (0, logger_1.logDebugMessage)("getAntiCSRFToken: called");
              return [4, getLocalSessionState(true)];
            case 1:
              if (!(_b.sent().status === "EXISTS")) {
                (0, logger_1.logDebugMessage)(
                  "getAntiCSRFToken: Returning because local session state != EXISTS"
                );
                return [2, null];
              }
              return [4, getAntiCSRFromCookie()];
            case 2:
              fromCookie = _b.sent();
              (0, logger_1.logDebugMessage)("getAntiCSRFToken: returning: " + fromCookie);
              return [2, fromCookie];
          }
        });
      });
    }
    function setAntiCSRF(antiCSRFToken) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              (0, logger_1.logDebugMessage)("setAntiCSRF: called: " + antiCSRFToken);
              if (!(antiCSRFToken !== void 0))
                return [3, 2];
              return [4, storeInCookies(ANTI_CSRF_NAME, antiCSRFToken, Number.MAX_SAFE_INTEGER)];
            case 1:
              _b.sent();
              return [3, 4];
            case 2:
              return [4, storeInCookies(ANTI_CSRF_NAME, "", 0)];
            case 3:
              _b.sent();
              _b.label = 4;
            case 4:
              return [2];
          }
        });
      });
    }
    exports.setAntiCSRF = setAntiCSRF;
    function getFrontTokenFromCookie() {
      return __awaiter(this, void 0, void 0, function() {
        var val;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              (0, logger_1.logDebugMessage)("getFrontTokenFromCookie: called");
              return [4, getFromCookies(FRONT_TOKEN_NAME)];
            case 1:
              val = _b.sent();
              return [2, val === void 0 ? null : val];
          }
        });
      });
    }
    function parseFrontToken(frontToken) {
      return JSON.parse(decodeURIComponent(escape(atob(frontToken))));
    }
    function getFrontToken() {
      return __awaiter(this, void 0, void 0, function() {
        var fromCookie;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              (0, logger_1.logDebugMessage)("getFrontToken: called");
              return [4, getLocalSessionState(true)];
            case 1:
              if (!(_b.sent().status === "EXISTS")) {
                (0, logger_1.logDebugMessage)("getFrontToken: Returning because sIRTFrontend != EXISTS");
                return [2, null];
              }
              return [4, getFrontTokenFromCookie()];
            case 2:
              fromCookie = _b.sent();
              (0, logger_1.logDebugMessage)("getFrontToken: returning: " + fromCookie);
              return [2, fromCookie];
          }
        });
      });
    }
    exports.getFrontToken = getFrontToken;
    function setFrontToken(frontToken) {
      return __awaiter(this, void 0, void 0, function() {
        var oldToken, oldPayload, newPayload;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              (0, logger_1.logDebugMessage)("setFrontToken: called");
              return [4, getFrontTokenFromCookie()];
            case 1:
              oldToken = _b.sent();
              if (oldToken !== null && frontToken !== void 0) {
                oldPayload = parseFrontToken(oldToken).up;
                newPayload = parseFrontToken(frontToken).up;
                if (JSON.stringify(oldPayload) !== JSON.stringify(newPayload)) {
                  onTokenUpdate();
                }
              }
              if (!(frontToken === void 0))
                return [3, 3];
              return [4, storeInCookies(FRONT_TOKEN_NAME, "", 0)];
            case 2:
              _b.sent();
              return [3, 5];
            case 3:
              return [4, storeInCookies(FRONT_TOKEN_NAME, frontToken, Number.MAX_SAFE_INTEGER)];
            case 4:
              _b.sent();
              _b.label = 5;
            case 5:
              return [2];
          }
        });
      });
    }
    exports.setFrontToken = setFrontToken;
    function fireSessionUpdateEventsIfNecessary(wasLoggedIn, status, frontTokenHeaderFromResponse) {
      if (frontTokenHeaderFromResponse === void 0 || frontTokenHeaderFromResponse === null) {
        (0, logger_1.logDebugMessage)(
          "fireSessionUpdateEventsIfNecessary returning early because the front token was not updated"
        );
        return;
      }
      var frontTokenExistsAfter = frontTokenHeaderFromResponse !== "remove";
      (0, logger_1.logDebugMessage)(
        "fireSessionUpdateEventsIfNecessary wasLoggedIn: ".concat(wasLoggedIn, " frontTokenExistsAfter: ").concat(frontTokenExistsAfter, " status: ").concat(status)
      );
      if (wasLoggedIn) {
        if (!frontTokenExistsAfter) {
          if (status === AuthHttpRequest.config.sessionExpiredStatusCode) {
            (0, logger_1.logDebugMessage)("onUnauthorisedResponse: firing UNAUTHORISED event");
            AuthHttpRequest.config.onHandleEvent({
              action: "UNAUTHORISED",
              sessionExpiredOrRevoked: true,
              userContext: {}
            });
          } else {
            (0, logger_1.logDebugMessage)("onUnauthorisedResponse: firing SIGN_OUT event");
            AuthHttpRequest.config.onHandleEvent({
              action: "SIGN_OUT",
              userContext: {}
            });
          }
        }
      } else if (frontTokenExistsAfter) {
        (0, logger_1.logDebugMessage)("onUnauthorisedResponse: firing SESSION_CREATED event");
        AuthHttpRequest.config.onHandleEvent({
          action: "SESSION_CREATED",
          userContext: {}
        });
      }
    }
    exports.fireSessionUpdateEventsIfNecessary = fireSessionUpdateEventsIfNecessary;
  }
});

// node_modules/supertokens-website/lib/build/utils/sessionClaimValidatorStore.js
var require_sessionClaimValidatorStore = __commonJS({
  "node_modules/supertokens-website/lib/build/utils/sessionClaimValidatorStore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SessionClaimValidatorStore = void 0;
    var SessionClaimValidatorStore = function() {
      function SessionClaimValidatorStore2() {
      }
      SessionClaimValidatorStore2.claimValidatorsAddedByOtherRecipes = [];
      SessionClaimValidatorStore2.addClaimValidatorFromOtherRecipe = function(builder) {
        SessionClaimValidatorStore2.claimValidatorsAddedByOtherRecipes.push(builder);
      };
      SessionClaimValidatorStore2.getClaimValidatorsAddedByOtherRecipes = function() {
        return SessionClaimValidatorStore2.claimValidatorsAddedByOtherRecipes;
      };
      return SessionClaimValidatorStore2;
    }();
    exports.SessionClaimValidatorStore = SessionClaimValidatorStore;
    exports.default = SessionClaimValidatorStore;
  }
});

// node_modules/supertokens-website/lib/build/utils/globalClaimValidators.js
var require_globalClaimValidators = __commonJS({
  "node_modules/supertokens-website/lib/build/utils/globalClaimValidators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGlobalClaimValidators = void 0;
    var _1 = require_utils();
    var fetch_1 = require_fetch();
    var sessionClaimValidatorStore_1 = require_sessionClaimValidatorStore();
    function getGlobalClaimValidators(overrideGlobalClaimValidators, userContext) {
      var normalisedUserContext = (0, _1.getNormalisedUserContext)(userContext);
      var claimValidatorsAddedByOtherRecipes = sessionClaimValidatorStore_1.default.getClaimValidatorsAddedByOtherRecipes();
      var globalClaimValidators = fetch_1.default.recipeImpl.getGlobalClaimValidators({
        claimValidatorsAddedByOtherRecipes,
        userContext: normalisedUserContext
      });
      var claimValidators = overrideGlobalClaimValidators !== void 0 ? overrideGlobalClaimValidators(globalClaimValidators, normalisedUserContext) : globalClaimValidators;
      return claimValidators;
    }
    exports.getGlobalClaimValidators = getGlobalClaimValidators;
  }
});

// node_modules/supertokens-website/utils/globalClaimValidators/index.js
var require_globalClaimValidators2 = __commonJS({
  "node_modules/supertokens-website/utils/globalClaimValidators/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    __export(require_globalClaimValidators());
  }
});

// node_modules/supertokens-web-js/lib/build/utils.js
var require_utils2 = __commonJS({
  "node_modules/supertokens-web-js/lib/build/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGlobalClaimValidators = exports.getHashFromLocation = exports.getNormalisedUserContext = exports.checkForSSRErrorAndAppendIfNeeded = exports.getAllQueryParams = exports.getQueryParams = exports.isTest = exports.normaliseInputAppInfoOrThrowError = exports.appendQueryParamsToURL = void 0;
    var windowHandler_1 = require_windowHandler3();
    var constants_1 = require_constants();
    var normalisedURLDomain_1 = require_normalisedURLDomain();
    var normalisedURLPath_1 = require_normalisedURLPath();
    var globalClaimValidators_1 = require_globalClaimValidators2();
    function appendQueryParamsToURL(stringUrl, queryParams) {
      if (queryParams === void 0) {
        return stringUrl;
      }
      try {
        var url_1 = new URL(stringUrl);
        Object.entries(queryParams).forEach(function(_a) {
          var key = _a[0], value = _a[1];
          url_1.searchParams.set(key, value);
        });
        return url_1.href;
      } catch (e) {
        var fakeDomain = stringUrl.startsWith("/") ? "http:localhost" : "http://localhost/";
        var url_2 = new URL("".concat(fakeDomain).concat(stringUrl));
        Object.entries(queryParams).forEach(function(_a) {
          var key = _a[0], value = _a[1];
          url_2.searchParams.set(key, value);
        });
        return "".concat(url_2.pathname).concat(url_2.search);
      }
    }
    exports.appendQueryParamsToURL = appendQueryParamsToURL;
    function getNormalisedURLPathOrDefault(defaultPath, path) {
      if (path !== void 0) {
        return new normalisedURLPath_1.default(path);
      } else {
        return new normalisedURLPath_1.default(defaultPath);
      }
    }
    function normaliseInputAppInfoOrThrowError(appInfo) {
      if (appInfo === void 0) {
        throw new Error("Please provide the appInfo object when calling supertokens.init");
      }
      if (appInfo.apiDomain === void 0) {
        throw new Error("Please provide your apiDomain inside the appInfo object when calling supertokens.init");
      }
      if (appInfo.appName === void 0) {
        throw new Error("Please provide your appName inside the appInfo object when calling supertokens.init");
      }
      var apiGatewayPath = new normalisedURLPath_1.default("");
      if (appInfo.apiGatewayPath !== void 0) {
        apiGatewayPath = new normalisedURLPath_1.default(appInfo.apiGatewayPath);
      }
      return {
        appName: appInfo.appName,
        apiDomain: new normalisedURLDomain_1.default(appInfo.apiDomain),
        apiBasePath: apiGatewayPath.appendPath(
          getNormalisedURLPathOrDefault(constants_1.DEFAULT_API_BASE_PATH, appInfo.apiBasePath)
        )
      };
    }
    exports.normaliseInputAppInfoOrThrowError = normaliseInputAppInfoOrThrowError;
    function isTest() {
      try {
        return process.env.TEST_MODE === "testing";
      } catch (err) {
        return false;
      }
    }
    exports.isTest = isTest;
    function getQueryParams(param) {
      var urlParams = new URLSearchParams(
        windowHandler_1.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getSearch()
      );
      var queryParam = urlParams.get(param);
      if (queryParam === null) {
        return void 0;
      }
      return queryParam;
    }
    exports.getQueryParams = getQueryParams;
    function getAllQueryParams() {
      return new URLSearchParams(
        windowHandler_1.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getSearch()
      );
    }
    exports.getAllQueryParams = getAllQueryParams;
    function checkForSSRErrorAndAppendIfNeeded(error) {
      if (typeof window === "undefined") {
        error = error + constants_1.SSR_ERROR;
      }
      return error;
    }
    exports.checkForSSRErrorAndAppendIfNeeded = checkForSSRErrorAndAppendIfNeeded;
    function getNormalisedUserContext(userContext) {
      return userContext === void 0 ? {} : userContext;
    }
    exports.getNormalisedUserContext = getNormalisedUserContext;
    function getHashFromLocation() {
      return windowHandler_1.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHash().substring(1);
    }
    exports.getHashFromLocation = getHashFromLocation;
    function getGlobalClaimValidators(_a) {
      var overrideGlobalClaimValidators = _a.overrideGlobalClaimValidators, userContext = _a.userContext;
      return (0, globalClaimValidators_1.getGlobalClaimValidators)(overrideGlobalClaimValidators, userContext);
    }
    exports.getGlobalClaimValidators = getGlobalClaimValidators;
  }
});

// node_modules/supertokens-website/utils/cookieHandler/index.js
var require_cookieHandler2 = __commonJS({
  "node_modules/supertokens-website/utils/cookieHandler/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    __export(require_cookieHandler());
  }
});

// node_modules/supertokens-web-js/lib/build/cookieHandler/index.js
var require_cookieHandler3 = __commonJS({
  "node_modules/supertokens-web-js/lib/build/cookieHandler/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CookieHandlerReference = void 0;
    var cookieHandler_1 = require_cookieHandler2();
    Object.defineProperty(exports, "CookieHandlerReference", {
      enumerable: true,
      get: function() {
        return cookieHandler_1.CookieHandlerReference;
      }
    });
  }
});

// node_modules/supertokens-web-js/lib/build/postSuperTokensInitCallbacks.js
var require_postSuperTokensInitCallbacks = __commonJS({
  "node_modules/supertokens-web-js/lib/build/postSuperTokensInitCallbacks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PostSuperTokensInitCallbacks = void 0;
    var PostSuperTokensInitCallbacks = function() {
      function PostSuperTokensInitCallbacks2() {
      }
      PostSuperTokensInitCallbacks2.addPostInitCallback = function(cb) {
        PostSuperTokensInitCallbacks2.postInitCallbacks.push(cb);
      };
      PostSuperTokensInitCallbacks2.runPostInitCallbacks = function() {
        for (var _i = 0, _a = PostSuperTokensInitCallbacks2.postInitCallbacks; _i < _a.length; _i++) {
          var cb = _a[_i];
          cb();
        }
      };
      PostSuperTokensInitCallbacks2.postInitCallbacks = [];
      return PostSuperTokensInitCallbacks2;
    }();
    exports.PostSuperTokensInitCallbacks = PostSuperTokensInitCallbacks;
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/recipeModule/utils.js
var require_utils3 = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/recipeModule/utils.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normaliseRecipeModuleConfig = void 0;
    function normaliseRecipeModuleConfig(config) {
      var _this = this;
      var preAPIHook = config.preAPIHook;
      if (preAPIHook === void 0) {
        preAPIHook = function(context) {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, context];
            });
          });
        };
      }
      var postAPIHook = config.postAPIHook;
      if (postAPIHook === void 0) {
        postAPIHook = function() {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2];
            });
          });
        };
      }
      return {
        recipeId: config.recipeId,
        appInfo: config.appInfo,
        clientType: config.clientType,
        preAPIHook,
        postAPIHook
      };
    }
    exports.normaliseRecipeModuleConfig = normaliseRecipeModuleConfig;
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/authRecipe/utils.js
var require_utils4 = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/authRecipe/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normaliseAuthRecipe = void 0;
    var utils_1 = require_utils3();
    function normaliseAuthRecipe(config) {
      return (0, utils_1.normaliseRecipeModuleConfig)(config);
    }
    exports.normaliseAuthRecipe = normaliseAuthRecipe;
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/multitenancy/utils.js
var require_utils5 = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/multitenancy/utils.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normaliseUserInput = void 0;
    var utils_1 = require_utils4();
    function normaliseUserInput(config) {
      var override = __assign(
        {
          functions: function(originalImplementation) {
            return originalImplementation;
          }
        },
        config.override
      );
      return __assign(__assign({}, (0, utils_1.normaliseAuthRecipe)(config)), { override });
    }
    exports.normaliseUserInput = normaliseUserInput;
  }
});

// node_modules/supertokens-js-override/lib/build/getProxyObject.js
var require_getProxyObject = __commonJS({
  "node_modules/supertokens-js-override/lib/build/getProxyObject.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProxyObject = void 0;
    function getProxyObject(orig) {
      var ret = __assign(__assign({}, orig), { _call: function(_, __) {
        throw new Error("This function should only be called through the recipe object");
      } });
      var keys = Object.keys(ret);
      var _loop_1 = function(k2) {
        if (k2 !== "_call") {
          ret[k2] = function() {
            var args = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              args[_i2] = arguments[_i2];
            }
            return this._call(k2, args);
          };
        }
      };
      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var k = keys_1[_i];
        _loop_1(k);
      }
      return ret;
    }
    exports.getProxyObject = getProxyObject;
  }
});

// node_modules/supertokens-js-override/lib/build/index.js
var require_build = __commonJS({
  "node_modules/supertokens-js-override/lib/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OverrideableBuilder = void 0;
    var getProxyObject_1 = require_getProxyObject();
    var OverrideableBuilder = function() {
      function OverrideableBuilder2(originalImplementation) {
        this.layers = [originalImplementation];
        this.proxies = [];
      }
      OverrideableBuilder2.prototype.override = function(overrideFunc) {
        var proxy = (0, getProxyObject_1.getProxyObject)(this.layers[0]);
        var layer = overrideFunc(proxy, this);
        for (var _i = 0, _a = Object.keys(this.layers[0]); _i < _a.length; _i++) {
          var key = _a[_i];
          if (layer[key] === proxy[key] || key === "_call") {
            delete layer[key];
          } else if (layer[key] === void 0) {
            layer[key] = null;
          }
        }
        this.layers.push(layer);
        this.proxies.push(proxy);
        return this;
      };
      OverrideableBuilder2.prototype.build = function() {
        var _this = this;
        if (this.result) {
          return this.result;
        }
        this.result = {};
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
          var layer = _a[_i];
          for (var _b = 0, _c = Object.keys(layer); _b < _c.length; _b++) {
            var key = _c[_b];
            var override = layer[key];
            if (override !== void 0) {
              if (override === null) {
                this.result[key] = void 0;
              } else if (typeof override === "function") {
                this.result[key] = override.bind(this.result);
              } else {
                this.result[key] = override;
              }
            }
          }
        }
        var _loop_1 = function(proxyInd2) {
          var proxy = this_1.proxies[proxyInd2];
          proxy._call = function(fname, args) {
            for (var i = proxyInd2; i >= 0; --i) {
              var func = _this.layers[i][fname];
              if (func !== void 0 && func !== null) {
                return func.bind(_this.result).apply(void 0, args);
              }
            }
          };
        };
        var this_1 = this;
        for (var proxyInd = 0; proxyInd < this.proxies.length; ++proxyInd) {
          _loop_1(proxyInd);
        }
        return this.result;
      };
      return OverrideableBuilder2;
    }();
    exports.OverrideableBuilder = OverrideableBuilder;
    exports.default = OverrideableBuilder;
  }
});

// node_modules/supertokens-web-js/lib/build/version.js
var require_version2 = __commonJS({
  "node_modules/supertokens-web-js/lib/build/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.supported_fdi = exports.package_version = void 0;
    exports.package_version = "0.7.3";
    exports.supported_fdi = ["1.17"];
  }
});

// node_modules/supertokens-website/lib/build/error.js
var require_error = __commonJS({
  "node_modules/supertokens-website/lib/build/error.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.STGeneralError = void 0;
    var STGeneralError = function(_super) {
      __extends(STGeneralError2, _super);
      function STGeneralError2(message) {
        var _this = _super.call(this, message) || this;
        _this.isSuperTokensGeneralError = true;
        return _this;
      }
      STGeneralError2.isThisError = function(err) {
        return err.isSuperTokensGeneralError === true;
      };
      return STGeneralError2;
    }(Error);
    exports.STGeneralError = STGeneralError;
  }
});

// node_modules/supertokens-website/utils/error/index.js
var require_error2 = __commonJS({
  "node_modules/supertokens-website/utils/error/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    var d = require_error();
    if (d.default !== void 0) {
      __export(d);
    } else {
      __export({
        default: d,
        ...d
      });
    }
  }
});

// node_modules/supertokens-web-js/lib/build/error.js
var require_error3 = __commonJS({
  "node_modules/supertokens-web-js/lib/build/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var error_1 = require_error2();
    exports.default = error_1.STGeneralError;
  }
});

// node_modules/supertokens-web-js/lib/build/querier.js
var require_querier = __commonJS({
  "node_modules/supertokens-web-js/lib/build/querier.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var normalisedURLPath_1 = require_normalisedURLPath();
    var version_1 = require_version2();
    var error_1 = require_error3();
    var Querier = function() {
      function Querier2(recipeId, appInfo) {
        var _this = this;
        this.recipeId = recipeId;
        this.appInfo = appInfo;
        this.get = function(tenantId, path, config, queryParams, preAPIHook, postAPIHook) {
          return __awaiter(_this, void 0, void 0, function() {
            var result, jsonBody;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [
                    4,
                    this.fetch(
                      this.getFullUrl(tenantId, path, queryParams),
                      __assign({ method: "GET" }, config),
                      preAPIHook,
                      postAPIHook
                    )
                  ];
                case 1:
                  result = _b.sent();
                  return [4, this.getResponseJsonOrThrowGeneralError(result)];
                case 2:
                  jsonBody = _b.sent();
                  return [
                    2,
                    {
                      jsonBody,
                      fetchResponse: result
                    }
                  ];
              }
            });
          });
        };
        this.post = function(tenantId, path, config, preAPIHook, postAPIHook) {
          return __awaiter(_this, void 0, void 0, function() {
            var result, jsonBody;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (config.body === void 0) {
                    throw new Error("Post request must have a body");
                  }
                  return [
                    4,
                    this.fetch(
                      this.getFullUrl(tenantId, path),
                      __assign({ method: "POST" }, config),
                      preAPIHook,
                      postAPIHook
                    )
                  ];
                case 1:
                  result = _b.sent();
                  return [4, this.getResponseJsonOrThrowGeneralError(result)];
                case 2:
                  jsonBody = _b.sent();
                  return [
                    2,
                    {
                      jsonBody,
                      fetchResponse: result
                    }
                  ];
              }
            });
          });
        };
        this.delete = function(tenantId, path, config, preAPIHook, postAPIHook) {
          return __awaiter(_this, void 0, void 0, function() {
            var result, jsonBody;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [
                    4,
                    this.fetch(
                      this.getFullUrl(tenantId, path),
                      __assign({ method: "DELETE" }, config),
                      preAPIHook,
                      postAPIHook
                    )
                  ];
                case 1:
                  result = _b.sent();
                  return [4, this.getResponseJsonOrThrowGeneralError(result)];
                case 2:
                  jsonBody = _b.sent();
                  return [
                    2,
                    {
                      jsonBody,
                      fetchResponse: result
                    }
                  ];
              }
            });
          });
        };
        this.put = function(tenantId, path, config, preAPIHook, postAPIHook) {
          return __awaiter(_this, void 0, void 0, function() {
            var result, jsonBody;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [
                    4,
                    this.fetch(
                      this.getFullUrl(tenantId, path),
                      __assign({ method: "PUT" }, config),
                      preAPIHook,
                      postAPIHook
                    )
                  ];
                case 1:
                  result = _b.sent();
                  return [4, this.getResponseJsonOrThrowGeneralError(result)];
                case 2:
                  jsonBody = _b.sent();
                  return [
                    2,
                    {
                      jsonBody,
                      fetchResponse: result
                    }
                  ];
              }
            });
          });
        };
        this.fetch = function(url, config, preAPIHook, postAPIHook) {
          return __awaiter(_this, void 0, void 0, function() {
            var headers, _b, requestInit, modifiedUrl, result, reponseForPostAPI;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  if (config === void 0) {
                    headers = {};
                  } else {
                    headers = config.headers;
                  }
                  return [
                    4,
                    this.callPreAPIHook({
                      preAPIHook,
                      url,
                      requestInit: __assign(__assign({}, config), {
                        headers: __assign(__assign({}, headers), {
                          "fdi-version": version_1.supported_fdi.join(","),
                          "Content-Type": "application/json",
                          rid: this.recipeId
                        })
                      })
                    })
                  ];
                case 1:
                  _b = _c.sent(), requestInit = _b.requestInit, modifiedUrl = _b.url;
                  return [4, fetch(modifiedUrl, requestInit)];
                case 2:
                  result = _c.sent();
                  if (result.status >= 300) {
                    throw result;
                  }
                  if (!(postAPIHook !== void 0))
                    return [3, 4];
                  reponseForPostAPI = result.clone();
                  return [
                    4,
                    postAPIHook({
                      requestInit,
                      url,
                      fetchResponse: reponseForPostAPI
                    })
                  ];
                case 3:
                  _c.sent();
                  _c.label = 4;
                case 4:
                  return [2, result];
              }
            });
          });
        };
        this.callPreAPIHook = function(context) {
          return __awaiter(_this, void 0, void 0, function() {
            var result;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (context.preAPIHook === void 0) {
                    return [
                      2,
                      {
                        url: context.url,
                        requestInit: context.requestInit
                      }
                    ];
                  }
                  return [
                    4,
                    context.preAPIHook({
                      url: context.url,
                      requestInit: context.requestInit
                    })
                  ];
                case 1:
                  result = _b.sent();
                  return [2, result];
              }
            });
          });
        };
        this.getFullUrl = function(tenantId, pathStr, queryParams) {
          var basePath = _this.appInfo.apiBasePath.getAsStringDangerous();
          if (tenantId !== void 0 && tenantId !== "public") {
            basePath = "".concat(basePath, "/").concat(tenantId);
          }
          var path = new normalisedURLPath_1.default(pathStr);
          var fullUrl = "".concat(_this.appInfo.apiDomain.getAsStringDangerous()).concat(basePath).concat(path.getAsStringDangerous());
          if (queryParams === void 0) {
            return fullUrl;
          }
          return fullUrl + "?" + new URLSearchParams(queryParams);
        };
        this.getResponseJsonOrThrowGeneralError = function(response) {
          return __awaiter(_this, void 0, void 0, function() {
            var json, message;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, response.clone().json()];
                case 1:
                  json = _b.sent();
                  if (json.status === "GENERAL_ERROR") {
                    message = json.message === void 0 ? "No Error Message Provided" : json.message;
                    throw new error_1.default(message);
                  }
                  return [2, json];
              }
            });
          });
        };
      }
      var _a;
      _a = Querier2;
      Querier2.preparePreAPIHook = function(_b) {
        var recipePreAPIHook = _b.recipePreAPIHook, action = _b.action, options = _b.options, userContext = _b.userContext;
        return function(context) {
          return __awaiter(void 0, void 0, void 0, function() {
            var postRecipeHookContext;
            return __generator(_a, function(_b2) {
              switch (_b2.label) {
                case 0:
                  return [
                    4,
                    recipePreAPIHook(
                      __assign(__assign({}, context), { action, userContext })
                    )
                  ];
                case 1:
                  postRecipeHookContext = _b2.sent();
                  if (options === void 0 || options.preAPIHook === void 0) {
                    return [2, postRecipeHookContext];
                  }
                  return [
                    2,
                    options.preAPIHook({
                      url: postRecipeHookContext.url,
                      requestInit: postRecipeHookContext.requestInit,
                      userContext
                    })
                  ];
              }
            });
          });
        };
      };
      Querier2.preparePostAPIHook = function(_b) {
        var recipePostAPIHook = _b.recipePostAPIHook, action = _b.action, userContext = _b.userContext;
        return function(context) {
          return __awaiter(void 0, void 0, void 0, function() {
            return __generator(_a, function(_b2) {
              switch (_b2.label) {
                case 0:
                  return [
                    4,
                    recipePostAPIHook(
                      __assign(__assign({}, context), { userContext, action })
                    )
                  ];
                case 1:
                  _b2.sent();
                  return [2];
              }
            });
          });
        };
      };
      return Querier2;
    }();
    exports.default = Querier;
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/multitenancy/recipeImplementation.js
var require_recipeImplementation = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/multitenancy/recipeImplementation.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRecipeImplementation = void 0;
    var querier_1 = require_querier();
    function getRecipeImplementation(recipeImplInput) {
      var querier = new querier_1.default(recipeImplInput.recipeId, recipeImplInput.appInfo);
      return {
        getTenantId: function() {
          return void 0;
        },
        getLoginMethods: function(_a) {
          var tenantId = _a.tenantId, options = _a.options, userContext = _a.userContext;
          return __awaiter(this, void 0, void 0, function() {
            var queryParams, _b, jsonBody, fetchResponse;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  queryParams = {};
                  if (recipeImplInput.clientType !== void 0) {
                    queryParams.clientType = recipeImplInput.clientType;
                  }
                  return [
                    4,
                    querier.get(
                      tenantId,
                      "/loginmethods",
                      {},
                      queryParams,
                      querier_1.default.preparePreAPIHook({
                        recipePreAPIHook: recipeImplInput.preAPIHook,
                        action: "GET_LOGIN_METHODS",
                        options,
                        userContext
                      }),
                      querier_1.default.preparePostAPIHook({
                        recipePostAPIHook: recipeImplInput.postAPIHook,
                        action: "GET_LOGIN_METHODS",
                        userContext
                      })
                    )
                  ];
                case 1:
                  _b = _c.sent(), jsonBody = _b.jsonBody, fetchResponse = _b.fetchResponse;
                  return [2, __assign(__assign({}, jsonBody), { fetchResponse })];
              }
            });
          });
        }
      };
    }
    exports.default = getRecipeImplementation;
    exports.getRecipeImplementation = getRecipeImplementation;
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/recipeModule/index.js
var require_recipeModule = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/recipeModule/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RecipeModule = function() {
      function RecipeModule2(config) {
        this.config = config;
      }
      return RecipeModule2;
    }();
    exports.default = RecipeModule;
  }
});

// node_modules/supertokens-website/lib/build/axiosError.js
var require_axiosError = __commonJS({
  "node_modules/supertokens-website/lib/build/axiosError.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAxiosErrorFromAxiosResp = exports.createAxiosErrorFromFetchResp = void 0;
    function enhanceAxiosError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code
        };
      };
      return error;
    }
    function createAxiosErrorFromFetchResp(response) {
      return __awaiter(this, void 0, void 0, function() {
        var config, contentType, data, _a, axiosResponse;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              config = {
                url: response.url,
                headers: response.headers
              };
              contentType = response.headers.get("content-type");
              if (!(contentType === null))
                return [3, 5];
              _b.label = 1;
            case 1:
              _b.trys.push([1, 3, , 4]);
              return [4, response.text()];
            case 2:
              data = _b.sent();
              return [3, 4];
            case 3:
              _a = _b.sent();
              data = "";
              return [3, 4];
            case 4:
              return [3, 11];
            case 5:
              if (!contentType.includes("application/json"))
                return [3, 7];
              return [4, response.json()];
            case 6:
              data = _b.sent();
              return [3, 11];
            case 7:
              if (!contentType.includes("text/"))
                return [3, 9];
              return [4, response.text()];
            case 8:
              data = _b.sent();
              return [3, 11];
            case 9:
              return [4, response.blob()];
            case 10:
              data = _b.sent();
              _b.label = 11;
            case 11:
              axiosResponse = {
                data,
                status: response.status,
                statusText: response.statusText,
                headers: response.headers,
                config,
                request: void 0
              };
              return [
                2,
                enhanceAxiosError(
                  new Error("Request failed with status code " + response.status),
                  config,
                  void 0,
                  void 0,
                  axiosResponse
                )
              ];
          }
        });
      });
    }
    exports.createAxiosErrorFromFetchResp = createAxiosErrorFromFetchResp;
    function createAxiosErrorFromAxiosResp(response) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          return [
            2,
            enhanceAxiosError(
              new Error("Request failed with status code " + response.status),
              response.config,
              void 0,
              response.request,
              response
            )
          ];
        });
      });
    }
    exports.createAxiosErrorFromAxiosResp = createAxiosErrorFromAxiosResp;
  }
});

// node_modules/supertokens-website/lib/build/axios.js
var require_axios = __commonJS({
  "node_modules/supertokens-website/lib/build/axios.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.responseErrorInterceptor = exports.responseInterceptor = exports.interceptorFunctionRequestFulfilled = void 0;
    var axiosError_1 = require_axiosError();
    var fetch_1 = require_fetch();
    var processState_1 = require_processState();
    var windowHandler_1 = require_windowHandler();
    var logger_1 = require_logger();
    function getUrlFromConfig(config) {
      var url = config.url === void 0 ? "" : config.url;
      var baseURL = config.baseURL;
      if (baseURL !== void 0) {
        if (url.charAt(0) === "/" && baseURL.charAt(baseURL.length - 1) === "/") {
          url = baseURL + url.substr(1);
        } else if (url.charAt(0) !== "/" && baseURL.charAt(baseURL.length - 1) !== "/") {
          url = baseURL + "/" + url;
        } else {
          url = baseURL + url;
        }
      }
      return url;
    }
    function interceptorFunctionRequestFulfilled(config) {
      return __awaiter(this, void 0, void 0, function() {
        var url, doNotDoInterception, preRequestLSS, configWithAntiCsrf, antiCsrfToken, transferMethod;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              (0, logger_1.logDebugMessage)("interceptorFunctionRequestFulfilled: started axios interception");
              url = getUrlFromConfig(config);
              doNotDoInterception = false;
              try {
                doNotDoInterception = typeof url === "string" && !fetch_1.default.recipeImpl.shouldDoInterceptionBasedOnUrl(
                  url,
                  fetch_1.default.config.apiDomain,
                  fetch_1.default.config.sessionTokenBackendDomain
                );
              } catch (err) {
                if (err.message === "Please provide a valid domain name") {
                  (0, logger_1.logDebugMessage)(
                    "interceptorFunctionRequestFulfilled: Trying shouldDoInterceptionBasedOnUrl with location.origin"
                  );
                  doNotDoInterception = !fetch_1.default.recipeImpl.shouldDoInterceptionBasedOnUrl(
                    windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(),
                    fetch_1.default.config.apiDomain,
                    fetch_1.default.config.sessionTokenBackendDomain
                  );
                } else {
                  throw err;
                }
              }
              (0, logger_1.logDebugMessage)("interceptorFunctionRequestFulfilled: Value of doNotDoInterception: " + doNotDoInterception);
              if (doNotDoInterception) {
                (0, logger_1.logDebugMessage)(
                  "interceptorFunctionRequestFulfilled: Returning config unchanged"
                );
                return [2, config];
              }
              (0, logger_1.logDebugMessage)("interceptorFunctionRequestFulfilled: Modifying config");
              processState_1.ProcessState.getInstance().addState(
                processState_1.PROCESS_STATE.CALLING_INTERCEPTION_REQUEST
              );
              return [4, (0, fetch_1.getLocalSessionState)(true)];
            case 1:
              preRequestLSS = _a.sent();
              configWithAntiCsrf = config;
              if (!(preRequestLSS.status === "EXISTS"))
                return [3, 3];
              return [4, fetch_1.AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)];
            case 2:
              antiCsrfToken = _a.sent();
              if (antiCsrfToken !== void 0) {
                (0, logger_1.logDebugMessage)(
                  "interceptorFunctionRequestFulfilled: Adding anti-csrf token to request"
                );
                configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {
                  headers: configWithAntiCsrf === void 0 ? {
                    "anti-csrf": antiCsrfToken
                  } : __assign(__assign({}, configWithAntiCsrf.headers), { "anti-csrf": antiCsrfToken })
                });
              }
              _a.label = 3;
            case 3:
              if (fetch_1.default.config.autoAddCredentials && configWithAntiCsrf.withCredentials === void 0) {
                (0, logger_1.logDebugMessage)(
                  "interceptorFunctionRequestFulfilled: Adding credentials include"
                );
                configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), { withCredentials: true });
              }
              (0, logger_1.logDebugMessage)("interceptorFunctionRequestFulfilled: Adding rid header: anti-csrf (it may be overriden by the user's provided rid)");
              configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {
                headers: configWithAntiCsrf === void 0 ? {
                  rid: "anti-csrf"
                } : __assign({ rid: "anti-csrf" }, configWithAntiCsrf.headers)
              });
              transferMethod = fetch_1.default.config.tokenTransferMethod;
              (0, logger_1.logDebugMessage)("interceptorFunctionRequestFulfilled: Adding st-auth-mode header: " + transferMethod);
              configWithAntiCsrf.headers["st-auth-mode"] = transferMethod;
              return [4, removeAuthHeaderIfMatchesLocalToken(configWithAntiCsrf)];
            case 4:
              configWithAntiCsrf = _a.sent();
              return [4, setAuthorizationHeaderIfRequired(configWithAntiCsrf)];
            case 5:
              _a.sent();
              (0, logger_1.logDebugMessage)("interceptorFunctionRequestFulfilled: returning modified config");
              return [2, configWithAntiCsrf];
          }
        });
      });
    }
    exports.interceptorFunctionRequestFulfilled = interceptorFunctionRequestFulfilled;
    function responseInterceptor(axiosInstance) {
      var _this = this;
      return function(response) {
        return __awaiter(_this, void 0, void 0, function() {
          var doNotDoInterception, url, preRequestLSS, config, _a;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                doNotDoInterception = false;
                _b.label = 1;
              case 1:
                _b.trys.push([1, , 8, 14]);
                if (!fetch_1.default.initCalled) {
                  throw new Error("init function not called");
                }
                (0, logger_1.logDebugMessage)("responseInterceptor: started");
                (0, logger_1.logDebugMessage)("responseInterceptor: already intercepted: " + response.headers["x-supertokens-xhr-intercepted"]);
                url = getUrlFromConfig(response.config);
                try {
                  doNotDoInterception = typeof url === "string" && !fetch_1.default.recipeImpl.shouldDoInterceptionBasedOnUrl(
                    url,
                    fetch_1.default.config.apiDomain,
                    fetch_1.default.config.sessionTokenBackendDomain
                  ) || !!response.headers["x-supertokens-xhr-intercepted"];
                } catch (err) {
                  if (err.message === "Please provide a valid domain name") {
                    (0, logger_1.logDebugMessage)(
                      "responseInterceptor: Trying shouldDoInterceptionBasedOnUrl with location.origin"
                    );
                    doNotDoInterception = !fetch_1.default.recipeImpl.shouldDoInterceptionBasedOnUrl(
                      windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(),
                      fetch_1.default.config.apiDomain,
                      fetch_1.default.config.sessionTokenBackendDomain
                    ) || !!response.headers["x-supertokens-xhr-intercepted"];
                  } else {
                    throw err;
                  }
                }
                (0, logger_1.logDebugMessage)("responseInterceptor: Value of doNotDoInterception: " + doNotDoInterception);
                if (doNotDoInterception) {
                  (0, logger_1.logDebugMessage)("responseInterceptor: Returning without interception");
                  return [2, response];
                }
                (0, logger_1.logDebugMessage)("responseInterceptor: Interception started");
                processState_1.ProcessState.getInstance().addState(
                  processState_1.PROCESS_STATE.CALLING_INTERCEPTION_RESPONSE
                );
                return [4, (0, fetch_1.getLocalSessionState)(false)];
              case 2:
                preRequestLSS = _b.sent();
                return [4, saveTokensFromHeaders(response)];
              case 3:
                _b.sent();
                (0, fetch_1.fireSessionUpdateEventsIfNecessary)(preRequestLSS.status === "EXISTS", response.status, response.headers["front-token"]);
                if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode))
                  return [3, 4];
                (0, logger_1.logDebugMessage)("responseInterceptor: Status code is: " + response.status);
                config = response.config;
                return [
                  2,
                  AuthHttpRequest.doRequest(
                    function(config2) {
                      return axiosInstance(config2);
                    },
                    config,
                    url,
                    response,
                    void 0,
                    true
                  )
                ];
              case 4:
                if (!(response.status === fetch_1.default.config.invalidClaimStatusCode))
                  return [3, 6];
                return [4, (0, fetch_1.onInvalidClaimResponse)(response)];
              case 5:
                _b.sent();
                _b.label = 6;
              case 6:
                return [2, response];
              case 7:
                return [3, 14];
              case 8:
                _a = !doNotDoInterception;
                if (!_a)
                  return [3, 10];
                return [4, (0, fetch_1.getLocalSessionState)(true)];
              case 9:
                _a = !(_b.sent().status === "EXISTS");
                _b.label = 10;
              case 10:
                if (!_a)
                  return [3, 13];
                (0, logger_1.logDebugMessage)("responseInterceptor: local session doesn't exist, so removing anti-csrf and sFrontToken");
                return [4, fetch_1.AntiCsrfToken.removeToken()];
              case 11:
                _b.sent();
                return [4, fetch_1.FrontToken.removeToken()];
              case 12:
                _b.sent();
                _b.label = 13;
              case 13:
                return [7];
              case 14:
                return [2];
            }
          });
        });
      };
    }
    exports.responseInterceptor = responseInterceptor;
    function responseErrorInterceptor(axiosInstance) {
      var _this = this;
      return function(error) {
        return __awaiter(_this, void 0, void 0, function() {
          var config;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                (0, logger_1.logDebugMessage)("responseErrorInterceptor: called");
                (0, logger_1.logDebugMessage)("responseErrorInterceptor: already intercepted: " + (error.response && error.response.headers["x-supertokens-xhr-intercepted"]));
                if (error.response.headers["x-supertokens-xhr-intercepted"]) {
                  throw error;
                }
                if (!(error.response !== void 0 && error.response.status === fetch_1.default.config.sessionExpiredStatusCode))
                  return [3, 1];
                (0, logger_1.logDebugMessage)("responseErrorInterceptor: Status code is: " + error.response.status);
                config = error.config;
                return [
                  2,
                  AuthHttpRequest.doRequest(
                    function(config2) {
                      return axiosInstance(config2);
                    },
                    config,
                    getUrlFromConfig(config),
                    void 0,
                    error,
                    true
                  )
                ];
              case 1:
                if (!(error.response !== void 0 && error.response.status === fetch_1.default.config.invalidClaimStatusCode))
                  return [3, 3];
                return [4, (0, fetch_1.onInvalidClaimResponse)(error.response)];
              case 2:
                _a.sent();
                _a.label = 3;
              case 3:
                throw error;
            }
          });
        });
      };
    }
    exports.responseErrorInterceptor = responseErrorInterceptor;
    var AuthHttpRequest = function() {
      function AuthHttpRequest2() {
      }
      var _a;
      _a = AuthHttpRequest2;
      AuthHttpRequest2.doRequest = function(httpCall, config, url, prevResponse, prevError, viaInterceptor) {
        if (viaInterceptor === void 0) {
          viaInterceptor = false;
        }
        return __awaiter(void 0, void 0, void 0, function() {
          var doNotDoInterception, returnObj, preRequestLSS, configWithAntiCsrf, antiCsrfToken, transferMethod, localPrevError, localPrevResponse, response, _b, refreshResult, _c, err_1, response, refreshResult, _d, postRequestIdToken;
          return __generator(_a, function(_e) {
            switch (_e.label) {
              case 0:
                if (!fetch_1.default.initCalled) {
                  throw Error("init function not called");
                }
                (0, logger_1.logDebugMessage)("doRequest: called");
                doNotDoInterception = false;
                try {
                  doNotDoInterception = typeof url === "string" && !fetch_1.default.recipeImpl.shouldDoInterceptionBasedOnUrl(
                    url,
                    fetch_1.default.config.apiDomain,
                    fetch_1.default.config.sessionTokenBackendDomain
                  ) && viaInterceptor;
                } catch (err) {
                  if (err.message === "Please provide a valid domain name") {
                    (0, logger_1.logDebugMessage)(
                      "doRequest: Trying shouldDoInterceptionBasedOnUrl with location.origin"
                    );
                    doNotDoInterception = !fetch_1.default.recipeImpl.shouldDoInterceptionBasedOnUrl(
                      windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(),
                      fetch_1.default.config.apiDomain,
                      fetch_1.default.config.sessionTokenBackendDomain
                    ) && viaInterceptor;
                  } else {
                    throw err;
                  }
                }
                (0, logger_1.logDebugMessage)("doRequest: Value of doNotDoInterception: " + doNotDoInterception);
                if (!doNotDoInterception)
                  return [3, 2];
                (0, logger_1.logDebugMessage)("doRequest: Returning without interception");
                if (prevError !== void 0) {
                  throw prevError;
                } else if (prevResponse !== void 0) {
                  return [2, prevResponse];
                }
                return [4, httpCall(config)];
              case 1:
                return [2, _e.sent()];
              case 2:
                (0, logger_1.logDebugMessage)("doRequest: Interception started");
                return [4, removeAuthHeaderIfMatchesLocalToken(config)];
              case 3:
                config = _e.sent();
                _e.label = 4;
              case 4:
                _e.trys.push([4, , 40, 45]);
                returnObj = void 0;
                _e.label = 5;
              case 5:
                if (false)
                  return [3, 39];
                return [4, (0, fetch_1.getLocalSessionState)(true)];
              case 6:
                preRequestLSS = _e.sent();
                configWithAntiCsrf = config;
                if (!(preRequestLSS.status === "EXISTS"))
                  return [3, 8];
                return [4, fetch_1.AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)];
              case 7:
                antiCsrfToken = _e.sent();
                if (antiCsrfToken !== void 0) {
                  (0, logger_1.logDebugMessage)("doRequest: Adding anti-csrf token to request");
                  configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {
                    headers: configWithAntiCsrf === void 0 ? {
                      "anti-csrf": antiCsrfToken
                    } : __assign(__assign({}, configWithAntiCsrf.headers), {
                      "anti-csrf": antiCsrfToken
                    })
                  });
                }
                _e.label = 8;
              case 8:
                if (fetch_1.default.config.autoAddCredentials && configWithAntiCsrf.withCredentials === void 0) {
                  (0, logger_1.logDebugMessage)("doRequest: Adding credentials include");
                  configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), { withCredentials: true });
                }
                (0, logger_1.logDebugMessage)("doRequest: Adding rid header: anti-csrf (May get overriden by user's rid)");
                configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {
                  headers: configWithAntiCsrf === void 0 ? {
                    rid: "anti-csrf"
                  } : __assign({ rid: "anti-csrf" }, configWithAntiCsrf.headers)
                });
                transferMethod = fetch_1.default.config.tokenTransferMethod;
                (0, logger_1.logDebugMessage)("doRequest: Adding st-auth-mode header: " + transferMethod);
                configWithAntiCsrf.headers["st-auth-mode"] = transferMethod;
                return [4, setAuthorizationHeaderIfRequired(configWithAntiCsrf)];
              case 9:
                _e.sent();
                _e.label = 10;
              case 10:
                _e.trys.push([10, 25, , 38]);
                localPrevError = prevError;
                localPrevResponse = prevResponse;
                prevError = void 0;
                prevResponse = void 0;
                if (localPrevError !== void 0) {
                  (0, logger_1.logDebugMessage)(
                    "doRequest: Not making call because localPrevError is not undefined"
                  );
                  throw localPrevError;
                }
                if (localPrevResponse !== void 0) {
                  (0, logger_1.logDebugMessage)(
                    "doRequest: Not making call because localPrevResponse is not undefined"
                  );
                } else {
                  (0, logger_1.logDebugMessage)("doRequest: Making user's http call");
                }
                if (!(localPrevResponse === void 0))
                  return [3, 12];
                return [4, httpCall(configWithAntiCsrf)];
              case 11:
                _b = _e.sent();
                return [3, 13];
              case 12:
                _b = localPrevResponse;
                _e.label = 13;
              case 13:
                response = _b;
                (0, logger_1.logDebugMessage)("doRequest: User's http call ended");
                return [4, saveTokensFromHeaders(response)];
              case 14:
                _e.sent();
                (0, fetch_1.fireSessionUpdateEventsIfNecessary)(preRequestLSS.status === "EXISTS", response.status, response.headers["front-token"]);
                if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode))
                  return [3, 21];
                (0, logger_1.logDebugMessage)("doRequest: Status code is: " + response.status);
                return [4, (0, fetch_1.onUnauthorisedResponse)(preRequestLSS)];
              case 15:
                refreshResult = _e.sent();
                if (!(refreshResult.result !== "RETRY"))
                  return [3, 20];
                (0, logger_1.logDebugMessage)("doRequest: Not retrying original request");
                if (!refreshResult.error)
                  return [3, 17];
                return [4, (0, axiosError_1.createAxiosErrorFromFetchResp)(refreshResult.error)];
              case 16:
                _c = _e.sent();
                return [3, 19];
              case 17:
                return [4, (0, axiosError_1.createAxiosErrorFromAxiosResp)(response)];
              case 18:
                _c = _e.sent();
                _e.label = 19;
              case 19:
                returnObj = _c;
                return [3, 39];
              case 20:
                (0, logger_1.logDebugMessage)("doRequest: Retrying original request");
                return [3, 24];
              case 21:
                if (!(response.status === fetch_1.default.config.invalidClaimStatusCode))
                  return [3, 23];
                return [4, (0, fetch_1.onInvalidClaimResponse)(response)];
              case 22:
                _e.sent();
                _e.label = 23;
              case 23:
                return [2, response];
              case 24:
                return [3, 38];
              case 25:
                err_1 = _e.sent();
                response = err_1.response;
                if (!(response !== void 0))
                  return [3, 36];
                return [4, saveTokensFromHeaders(response)];
              case 26:
                _e.sent();
                (0, fetch_1.fireSessionUpdateEventsIfNecessary)(preRequestLSS.status === "EXISTS", response.status, response.headers["front-token"]);
                if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode))
                  return [3, 32];
                (0, logger_1.logDebugMessage)("doRequest: Status code is: " + response.status);
                return [4, (0, fetch_1.onUnauthorisedResponse)(preRequestLSS)];
              case 27:
                refreshResult = _e.sent();
                if (!(refreshResult.result !== "RETRY"))
                  return [3, 31];
                (0, logger_1.logDebugMessage)("doRequest: Not retrying original request");
                if (!(refreshResult.error !== void 0))
                  return [3, 29];
                return [4, (0, axiosError_1.createAxiosErrorFromFetchResp)(refreshResult.error)];
              case 28:
                _d = _e.sent();
                return [3, 30];
              case 29:
                _d = err_1;
                _e.label = 30;
              case 30:
                returnObj = _d;
                return [3, 39];
              case 31:
                (0, logger_1.logDebugMessage)("doRequest: Retrying original request");
                return [3, 35];
              case 32:
                if (!(response.status === fetch_1.default.config.invalidClaimStatusCode))
                  return [3, 34];
                return [4, (0, fetch_1.onInvalidClaimResponse)(response)];
              case 33:
                _e.sent();
                _e.label = 34;
              case 34:
                throw err_1;
              case 35:
                return [3, 37];
              case 36:
                throw err_1;
              case 37:
                return [3, 38];
              case 38:
                return [3, 5];
              case 39:
                throw returnObj;
              case 40:
                return [4, (0, fetch_1.getLocalSessionState)(false)];
              case 41:
                postRequestIdToken = _e.sent();
                if (!(postRequestIdToken.status === "NOT_EXISTS"))
                  return [3, 44];
                (0, logger_1.logDebugMessage)("doRequest: local session doesn't exist, so removing anti-csrf and sFrontToken");
                return [4, fetch_1.AntiCsrfToken.removeToken()];
              case 42:
                _e.sent();
                return [4, fetch_1.FrontToken.removeToken()];
              case 43:
                _e.sent();
                _e.label = 44;
              case 44:
                return [7];
              case 45:
                return [2];
            }
          });
        });
      };
      return AuthHttpRequest2;
    }();
    exports.default = AuthHttpRequest;
    function setAuthorizationHeaderIfRequired(requestConfig) {
      return __awaiter(this, void 0, void 0, function() {
        var accessToken, refreshToken;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (requestConfig.headers === void 0) {
                requestConfig.headers = {};
              }
              (0, logger_1.logDebugMessage)("setAuthorizationHeaderIfRequired: adding existing tokens as header");
              return [4, (0, fetch_1.getTokenForHeaderAuth)("access")];
            case 1:
              accessToken = _b.sent();
              return [4, (0, fetch_1.getTokenForHeaderAuth)("refresh")];
            case 2:
              refreshToken = _b.sent();
              if (accessToken !== void 0 && refreshToken !== void 0) {
                if (requestConfig.headers["Authorization"] !== void 0 || requestConfig.headers["authorization"] !== void 0) {
                  (0, logger_1.logDebugMessage)(
                    "setAuthorizationHeaderIfRequired: Authorization header defined by the user, not adding"
                  );
                } else {
                  (0, logger_1.logDebugMessage)(
                    "setAuthorizationHeaderIfRequired: added authorization header"
                  );
                  requestConfig.headers = __assign(__assign({}, requestConfig.headers), {
                    Authorization: "Bearer ".concat(accessToken)
                  });
                  requestConfig.__supertokensAddedAuthHeader = true;
                }
              } else {
                (0, logger_1.logDebugMessage)(
                  "setAuthorizationHeaderIfRequired: token for header based auth not found"
                );
              }
              return [2];
          }
        });
      });
    }
    function saveTokensFromHeaders(response) {
      return __awaiter(this, void 0, void 0, function() {
        var refreshToken, accessToken, frontToken, antiCsrfToken, tok;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              (0, logger_1.logDebugMessage)("saveTokensFromHeaders: Saving updated tokens from the response");
              refreshToken = response.headers["st-refresh-token"];
              if (!(refreshToken !== void 0))
                return [3, 2];
              (0, logger_1.logDebugMessage)("saveTokensFromHeaders: saving new refresh token");
              return [4, (0, fetch_1.setToken)("refresh", refreshToken)];
            case 1:
              _b.sent();
              _b.label = 2;
            case 2:
              accessToken = response.headers["st-access-token"];
              if (!(accessToken !== void 0))
                return [3, 4];
              (0, logger_1.logDebugMessage)("saveTokensFromHeaders: saving new access token");
              return [4, (0, fetch_1.setToken)("access", accessToken)];
            case 3:
              _b.sent();
              _b.label = 4;
            case 4:
              frontToken = response.headers["front-token"];
              if (!(frontToken !== void 0))
                return [3, 6];
              (0, logger_1.logDebugMessage)("doRequest: Setting sFrontToken: " + frontToken);
              return [4, fetch_1.FrontToken.setItem(frontToken)];
            case 5:
              _b.sent();
              _b.label = 6;
            case 6:
              antiCsrfToken = response.headers["anti-csrf"];
              if (!(antiCsrfToken !== void 0))
                return [3, 9];
              return [4, (0, fetch_1.getLocalSessionState)(true)];
            case 7:
              tok = _b.sent();
              if (!(tok.status === "EXISTS"))
                return [3, 9];
              (0, logger_1.logDebugMessage)("doRequest: Setting anti-csrf token");
              return [4, fetch_1.AntiCsrfToken.setItem(tok.lastAccessTokenUpdate, antiCsrfToken)];
            case 8:
              _b.sent();
              _b.label = 9;
            case 9:
              return [2];
          }
        });
      });
    }
    function removeAuthHeaderIfMatchesLocalToken(config) {
      return __awaiter(this, void 0, void 0, function() {
        var accessToken, refreshToken, authHeader, res;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, (0, fetch_1.getTokenForHeaderAuth)("access")];
            case 1:
              accessToken = _b.sent();
              return [4, (0, fetch_1.getTokenForHeaderAuth)("refresh")];
            case 2:
              refreshToken = _b.sent();
              authHeader = config.headers.Authorization || config.headers.authorization;
              if (accessToken !== void 0 && refreshToken !== void 0) {
                if (authHeader === "Bearer ".concat(accessToken) || "__supertokensAddedAuthHeader" in config) {
                  (0, logger_1.logDebugMessage)(
                    "removeAuthHeaderIfMatchesLocalToken: Removing Authorization from user provided headers because it contains our access token"
                  );
                  res = __assign(__assign({}, config), { headers: __assign({}, config.headers) });
                  delete res.headers.authorization;
                  delete res.headers.Authorization;
                  return [2, res];
                }
              }
              return [2, config];
          }
        });
      });
    }
  }
});

// node_modules/supertokens-website/lib/build/xmlhttprequest.js
var require_xmlhttprequest = __commonJS({
  "node_modules/supertokens-website/lib/build/xmlhttprequest.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addInterceptorsToXMLHttpRequest = void 0;
    var fetch_1 = require_fetch();
    var logger_1 = require_logger();
    var windowHandler_1 = require_windowHandler();
    var processState_1 = require_processState();
    var XHR_EVENTS = ["readystatechange", "abort", "error", "load", "loadend", "loadstart", "progress", "timeout"];
    function addInterceptorsToXMLHttpRequest() {
      var firstEventLoopDone = new Promise(function(res) {
        return setTimeout(res, 0);
      });
      var oldXMLHttpRequest = XMLHttpRequest;
      (0, logger_1.logDebugMessage)("addInterceptorsToXMLHttpRequest called");
      XMLHttpRequest = function() {
        var actual = new oldXMLHttpRequest();
        var delayedQueue = firstEventLoopDone;
        function delayIfNecessary(cb) {
          delayedQueue = delayedQueue.finally(function() {
            var _a;
            return (_a = cb()) === null || _a === void 0 ? void 0 : _a.catch(console.error);
          });
        }
        var self = this;
        var listOfFunctionCallsInProxy = [];
        var requestHeaders = [];
        var customGetterValues = {};
        var customResponseHeaders;
        var eventHandlers = /* @__PURE__ */ new Map();
        var url = "";
        var doNotDoInterception = false;
        var preRequestLSS = void 0;
        var body;
        self.onload = null;
        self.onreadystatechange = null;
        self.onloadend = null;
        self.addEventListener = function(type, listener, _options) {
          var handlers = eventHandlers.get(type);
          if (handlers === void 0) {
            handlers = /* @__PURE__ */ new Set();
            eventHandlers.set(type, handlers);
          }
          handlers.add(listener);
        };
        self.removeEventListener = function(type, listener) {
          var handlers = eventHandlers.get(type);
          if (handlers === void 0) {
            handlers = /* @__PURE__ */ new Set();
            eventHandlers.set(type, handlers);
          }
          handlers.delete(listener);
        };
        function redispatchEvent(name, ev) {
          var handlers = eventHandlers.get(name);
          (0, logger_1.logDebugMessage)(
            "XHRInterceptor dispatching ".concat(ev.type, " to ").concat(handlers ? handlers.size : 0, " listeners")
          );
          if (handlers) {
            Array.from(handlers).forEach(function(handler) {
              return handler.apply(self, [ev]);
            });
          }
        }
        function handleRetryPostRefreshing() {
          return __awaiter(this, void 0, void 0, function() {
            var refreshResult, retryXhr;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (preRequestLSS === void 0) {
                    throw new Error("Should never come here..");
                  }
                  (0, logger_1.logDebugMessage)("XHRInterceptor.handleRetryPostRefreshing: preRequestLSS " + preRequestLSS.status);
                  return [4, (0, fetch_1.onUnauthorisedResponse)(preRequestLSS)];
                case 1:
                  refreshResult = _a.sent();
                  if (refreshResult.result !== "RETRY") {
                    (0, logger_1.logDebugMessage)(
                      "XHRInterceptor.handleRetryPostRefreshing: Not retrying original request " + !!refreshResult.error
                    );
                    if (refreshResult.error !== void 0) {
                      throw refreshResult.error;
                    }
                    return [2, true];
                  }
                  (0, logger_1.logDebugMessage)("XHRInterceptor.handleRetryPostRefreshing: Retrying original request");
                  retryXhr = new oldXMLHttpRequest();
                  setUpXHR(self, retryXhr, true);
                  listOfFunctionCallsInProxy.forEach(function(i) {
                    i(retryXhr);
                  });
                  sendXHR(retryXhr, body);
                  return [2, false];
              }
            });
          });
        }
        function handleResponse(xhr) {
          return __awaiter(this, void 0, void 0, function() {
            var status_1, headers, err_1, resp;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (doNotDoInterception) {
                    (0, logger_1.logDebugMessage)(
                      "XHRInterceptor.handleResponse: Returning without interception"
                    );
                    return [2, true];
                  }
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 14, , 18]);
                  _a.label = 2;
                case 2:
                  _a.trys.push([2, , 8, 13]);
                  (0, logger_1.logDebugMessage)("XHRInterceptor.handleResponse: Interception started");
                  processState_1.ProcessState.getInstance().addState(
                    processState_1.PROCESS_STATE.CALLING_INTERCEPTION_RESPONSE
                  );
                  status_1 = xhr.status;
                  headers = getResponseHeadersFromXHR(xhr);
                  return [4, saveTokensFromHeaders(headers)];
                case 3:
                  _a.sent();
                  (0, fetch_1.fireSessionUpdateEventsIfNecessary)(preRequestLSS.status === "EXISTS", status_1, headers.get("front-token"));
                  if (!(status_1 === fetch_1.default.config.sessionExpiredStatusCode))
                    return [3, 5];
                  (0, logger_1.logDebugMessage)("responseInterceptor: Status code is: " + status_1);
                  return [4, handleRetryPostRefreshing()];
                case 4:
                  return [2, _a.sent()];
                case 5:
                  if (!(status_1 === fetch_1.default.config.invalidClaimStatusCode))
                    return [3, 7];
                  return [
                    4,
                    (0, fetch_1.onInvalidClaimResponse)({
                      data: JSON.parse(xhr.responseText)
                    })
                  ];
                case 6:
                  _a.sent();
                  _a.label = 7;
                case 7:
                  return [2, true];
                case 8:
                  (0, logger_1.logDebugMessage)("XHRInterceptor.handleResponse: doFinallyCheck running");
                  return [4, (0, fetch_1.getLocalSessionState)(false)];
                case 9:
                  if (!!(_a.sent().status === "EXISTS"))
                    return [3, 12];
                  (0, logger_1.logDebugMessage)("XHRInterceptor.handleResponse: local session doesn't exist, so removing anti-csrf and sFrontToken");
                  return [4, fetch_1.AntiCsrfToken.removeToken()];
                case 10:
                  _a.sent();
                  return [4, fetch_1.FrontToken.removeToken()];
                case 11:
                  _a.sent();
                  _a.label = 12;
                case 12:
                  return [7];
                case 13:
                  return [3, 18];
                case 14:
                  err_1 = _a.sent();
                  (0, logger_1.logDebugMessage)("XHRInterceptor.handleResponse: caught error");
                  if (!(err_1.status !== void 0))
                    return [3, 16];
                  return [4, getXMLHttpStatusAndResponseTextFromFetchResponse(err_1)];
                case 15:
                  resp = _a.sent();
                  customGetterValues["status"] = resp.status;
                  customGetterValues["statusText"] = resp.statusText;
                  customGetterValues["responseType"] = resp.responseType;
                  customResponseHeaders = resp.headers;
                  if (resp.responseType === "json") {
                    try {
                      customGetterValues["response"] = JSON.parse(resp.responseText);
                    } catch (_b) {
                      customGetterValues["response"] = resp.responseText;
                    }
                  } else {
                    customGetterValues["response"] = resp.responseText;
                  }
                  customGetterValues["responseText"] = resp.responseText;
                  return [3, 17];
                case 16:
                  redispatchEvent("error", new Event("error"));
                  _a.label = 17;
                case 17:
                  return [2, true];
                case 18:
                  return [2];
              }
            });
          });
        }
        self.open = function(_, u) {
          (0, logger_1.logDebugMessage)("XHRInterceptor.open called");
          var args = arguments;
          url = u;
          try {
            doNotDoInterception = typeof url === "string" && !fetch_1.default.recipeImpl.shouldDoInterceptionBasedOnUrl(
              url,
              fetch_1.default.config.apiDomain,
              fetch_1.default.config.sessionTokenBackendDomain
            ) || typeof url !== "string" && !fetch_1.default.recipeImpl.shouldDoInterceptionBasedOnUrl(
              url.toString(),
              fetch_1.default.config.apiDomain,
              fetch_1.default.config.sessionTokenBackendDomain
            );
          } catch (err) {
            if (err.message === "Please provide a valid domain name") {
              (0, logger_1.logDebugMessage)(
                "XHRInterceptor.open: Trying shouldDoInterceptionBasedOnUrl with location.origin"
              );
              doNotDoInterception = !fetch_1.default.recipeImpl.shouldDoInterceptionBasedOnUrl(
                windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(),
                fetch_1.default.config.apiDomain,
                fetch_1.default.config.sessionTokenBackendDomain
              );
            } else {
              throw err;
            }
          }
          delayIfNecessary(function() {
            listOfFunctionCallsInProxy.push(function(xhr) {
              xhr.open.apply(xhr, args);
            });
            actual.open.apply(actual, args);
          });
        };
        self.send = function(inputBody) {
          body = inputBody;
          sendXHR(actual, body);
        };
        self.setRequestHeader = function(name, value) {
          var _this = this;
          (0, logger_1.logDebugMessage)("XHRInterceptor.setRequestHeader: Called with ".concat(name));
          if (doNotDoInterception) {
            delayIfNecessary(function() {
              return actual.setRequestHeader(name, value);
            });
            return;
          }
          if (name === "anti-csrf") {
            return;
          }
          delayIfNecessary(function() {
            return __awaiter(_this, void 0, void 0, function() {
              var accessToken, refreshToken;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (!(name.toLowerCase() === "authorization"))
                      return [3, 3];
                    (0, logger_1.logDebugMessage)("XHRInterceptor.setRequestHeader: checking if user provided auth header matches local token");
                    return [4, (0, fetch_1.getTokenForHeaderAuth)("access")];
                  case 1:
                    accessToken = _a.sent();
                    return [4, (0, fetch_1.getTokenForHeaderAuth)("refresh")];
                  case 2:
                    refreshToken = _a.sent();
                    if (accessToken !== void 0 && refreshToken !== void 0 && value === "Bearer ".concat(accessToken)) {
                      (0, logger_1.logDebugMessage)(
                        "XHRInterceptor.setRequestHeader: skipping Authorization from user provided headers because it contains our access token"
                      );
                      return [2];
                    }
                    _a.label = 3;
                  case 3:
                    listOfFunctionCallsInProxy.push(function(xhr) {
                      xhr.setRequestHeader(name, value);
                    });
                    requestHeaders.push({ name, value });
                    actual.setRequestHeader(name, value);
                    return [2];
                }
              });
            });
          });
        };
        var copiedProps = void 0;
        setUpXHR(self, actual, false);
        function setUpXHR(self2, xhr, isRetry) {
          var responseProcessed;
          var delayedEvents = ["load", "loadend", "readystatechange"];
          (0, logger_1.logDebugMessage)("XHRInterceptor.setUpXHR called");
          var _loop_1 = function(name_12) {
            (0, logger_1.logDebugMessage)("XHRInterceptor added listener for event ".concat(name_12));
            xhr.addEventListener(name_12, function(ev) {
              (0, logger_1.logDebugMessage)("XHRInterceptor got event ".concat(name_12));
              if (!delayedEvents.includes(name_12)) {
                redispatchEvent(name_12, ev);
              }
            });
          };
          for (var _i = 0, XHR_EVENTS_1 = XHR_EVENTS; _i < XHR_EVENTS_1.length; _i++) {
            var name_1 = XHR_EVENTS_1[_i];
            _loop_1(name_1);
          }
          xhr.onload = function(ev) {
            if (responseProcessed === void 0) {
              responseProcessed = handleResponse(xhr);
            }
            responseProcessed.then(function(callself) {
              if (!callself) {
                return;
              }
              if (self2.onload) {
                self2.onload(ev);
              }
              redispatchEvent("load", ev);
            });
          };
          xhr.onreadystatechange = function(ev) {
            if (xhr.readyState === oldXMLHttpRequest.DONE) {
              if (responseProcessed === void 0) {
                responseProcessed = handleResponse(xhr);
              }
              responseProcessed.then(function(callself) {
                if (!callself) {
                  return;
                }
                if (self2.onreadystatechange)
                  self2.onreadystatechange(ev);
                redispatchEvent("readystatechange", ev);
              });
            } else {
              if (self2.onreadystatechange) {
                self2.onreadystatechange(ev);
              }
              redispatchEvent("readystatechange", ev);
            }
          };
          xhr.onloadend = function(ev) {
            if (responseProcessed === void 0) {
              responseProcessed = handleResponse(xhr);
            }
            responseProcessed.then(function(callself) {
              if (!callself) {
                return;
              }
              if (self2.onloadend) {
                self2.onloadend(ev);
              }
              redispatchEvent("loadend", ev);
            });
          };
          self2.getAllResponseHeaders = function() {
            var headersString;
            if (customResponseHeaders) {
              headersString = "";
              customResponseHeaders.forEach(function(v, k) {
                return headersString += "".concat(k, ": ").concat(v, "\r\n");
              });
            } else {
              headersString = xhr.getAllResponseHeaders();
            }
            return headersString + "x-supertokens-xhr-intercepted: true\r\n";
          };
          self2.getResponseHeader = function(name) {
            if (name === "x-supertokens-xhr-intercepted") {
              return "true";
            }
            if (customResponseHeaders) {
              return customResponseHeaders.get(name);
            }
            return xhr.getResponseHeader(name);
          };
          if (copiedProps === void 0) {
            copiedProps = [];
            for (var prop in xhr) {
              if (!(prop in self2)) {
                copiedProps.push(prop);
              }
            }
          }
          var _loop_2 = function(prop2) {
            if (typeof xhr[prop2] === "function") {
              Object.defineProperty(self2, prop2, {
                configurable: true,
                value: function() {
                  var args = arguments;
                  if (!isRetry) {
                    listOfFunctionCallsInProxy.push(function(xhr2) {
                      xhr2[prop2].apply(xhr2, args);
                    });
                  }
                  return xhr[prop2].apply(xhr, args);
                }
              });
            } else {
              Object.defineProperty(self2, prop2, {
                configurable: true,
                get: function() {
                  if (customGetterValues[prop2] !== void 0) {
                    return customGetterValues[prop2];
                  }
                  return xhr[prop2];
                },
                set: function(val) {
                  if (!isRetry) {
                    listOfFunctionCallsInProxy.push(function(xhr2) {
                      xhr2[prop2] = val;
                    });
                  }
                  (0, logger_1.logDebugMessage)("XHRInterceptor.set[".concat(prop2, "] = ").concat(val));
                  xhr[prop2] = val;
                }
              });
            }
          };
          for (var _a = 0, copiedProps_1 = copiedProps; _a < copiedProps_1.length; _a++) {
            var prop = copiedProps_1[_a];
            _loop_2(prop);
          }
        }
        function sendXHR(xhr, body2) {
          var _this = this;
          (0, logger_1.logDebugMessage)("XHRInterceptor.send: called");
          (0, logger_1.logDebugMessage)("XHRInterceptor.send: Value of doNotDoInterception: " + doNotDoInterception);
          if (doNotDoInterception) {
            (0, logger_1.logDebugMessage)("XHRInterceptor.send: Returning without interception");
            delayIfNecessary(function() {
              return xhr.send(body2);
            });
            return;
          }
          (0, logger_1.logDebugMessage)("XHRInterceptor.send: Interception started");
          processState_1.ProcessState.getInstance().addState(
            processState_1.PROCESS_STATE.CALLING_INTERCEPTION_REQUEST
          );
          delayIfNecessary(function() {
            return __awaiter(_this, void 0, void 0, function() {
              var antiCsrfToken, transferMethod;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, (0, fetch_1.getLocalSessionState)(true)];
                  case 1:
                    preRequestLSS = _a.sent();
                    if (!(preRequestLSS.status === "EXISTS"))
                      return [3, 3];
                    return [
                      4,
                      fetch_1.AntiCsrfToken.getToken(preRequestLSS.lastAccessTokenUpdate)
                    ];
                  case 2:
                    antiCsrfToken = _a.sent();
                    if (antiCsrfToken !== void 0) {
                      (0, logger_1.logDebugMessage)(
                        "XHRInterceptor.send: Adding anti-csrf token to request"
                      );
                      xhr.setRequestHeader("anti-csrf", antiCsrfToken);
                    }
                    _a.label = 3;
                  case 3:
                    if (fetch_1.default.config.autoAddCredentials) {
                      (0, logger_1.logDebugMessage)("XHRInterceptor.send: Adding credentials include");
                      self.withCredentials = true;
                    }
                    if (!requestHeaders.some(function(i) {
                      return i.name === "rid";
                    })) {
                      (0, logger_1.logDebugMessage)("XHRInterceptor.send: Adding rid header: anti-csrf");
                      xhr.setRequestHeader("rid", "anti-csrf");
                    } else {
                      (0, logger_1.logDebugMessage)(
                        "XHRInterceptor.send: rid header was already there in request"
                      );
                    }
                    transferMethod = fetch_1.default.config.tokenTransferMethod;
                    if (!requestHeaders.some(function(i) {
                      return i.name === "st-auth-mode";
                    })) {
                      (0, logger_1.logDebugMessage)(
                        "XHRInterceptor.send: Adding st-auth-mode header: " + transferMethod
                      );
                      xhr.setRequestHeader("st-auth-mode", transferMethod);
                    } else {
                      (0, logger_1.logDebugMessage)(
                        "XHRInterceptor.send: st-auth-mode header was already there in request"
                      );
                    }
                    return [4, setAuthorizationHeaderIfRequired(xhr, requestHeaders)];
                  case 4:
                    _a.sent();
                    (0, logger_1.logDebugMessage)("XHRInterceptor.send: Making user's http call");
                    return [2, xhr.send(body2)];
                }
              });
            });
          });
        }
      };
      XMLHttpRequest.__interceptedBySuperTokens = true;
      XMLHttpRequest.__original = oldXMLHttpRequest;
    }
    exports.addInterceptorsToXMLHttpRequest = addInterceptorsToXMLHttpRequest;
    function getXMLHttpStatusAndResponseTextFromFetchResponse(response) {
      return __awaiter(this, void 0, void 0, function() {
        var contentType, data, responseType, _a, _b, _c;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              contentType = response.headers.get("content-type");
              data = "";
              responseType = "text";
              if (!(contentType === null))
                return [3, 5];
              _d.label = 1;
            case 1:
              _d.trys.push([1, 3, , 4]);
              return [4, response.text()];
            case 2:
              data = _d.sent();
              return [3, 4];
            case 3:
              _a = _d.sent();
              data = "";
              return [3, 4];
            case 4:
              return [3, 9];
            case 5:
              if (!contentType.includes("application/json"))
                return [3, 7];
              responseType = "json";
              _c = (_b = JSON).stringify;
              return [4, response.json()];
            case 6:
              data = _c.apply(_b, [_d.sent()]);
              return [3, 9];
            case 7:
              if (!contentType.includes("text/"))
                return [3, 9];
              return [4, response.text()];
            case 8:
              data = _d.sent();
              _d.label = 9;
            case 9:
              return [
                2,
                {
                  status: response.status,
                  responseText: data,
                  statusText: response.statusText,
                  responseType,
                  headers: response.headers
                }
              ];
          }
        });
      });
    }
    function setAuthorizationHeaderIfRequired(xhr, requestHeaders) {
      return __awaiter(this, void 0, void 0, function() {
        var accessToken, refreshToken;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              (0, logger_1.logDebugMessage)("setAuthorizationHeaderIfRequired: adding existing tokens as header");
              return [4, (0, fetch_1.getTokenForHeaderAuth)("access")];
            case 1:
              accessToken = _a.sent();
              return [4, (0, fetch_1.getTokenForHeaderAuth)("refresh")];
            case 2:
              refreshToken = _a.sent();
              if (accessToken !== void 0 && refreshToken !== void 0) {
                if (requestHeaders.some(function(_a2) {
                  var name = _a2.name;
                  return name.toLowerCase() === "authorization";
                })) {
                  (0, logger_1.logDebugMessage)(
                    "setAuthorizationHeaderIfRequired: Authorization header defined by the user, not adding"
                  );
                } else {
                  if (accessToken !== void 0) {
                    (0, logger_1.logDebugMessage)(
                      "setAuthorizationHeaderIfRequired: added authorization header"
                    );
                    xhr.setRequestHeader("Authorization", "Bearer ".concat(accessToken));
                  }
                }
              } else {
                (0, logger_1.logDebugMessage)(
                  "setAuthorizationHeaderIfRequired: token for header based auth not found"
                );
              }
              return [2];
          }
        });
      });
    }
    function saveTokensFromHeaders(headers) {
      return __awaiter(this, void 0, void 0, function() {
        var refreshToken, accessToken, frontToken, antiCsrfToken, tok;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              (0, logger_1.logDebugMessage)("saveTokensFromHeaders: Saving updated tokens from the response");
              refreshToken = headers.get("st-refresh-token");
              if (!(refreshToken !== null))
                return [3, 2];
              (0, logger_1.logDebugMessage)("saveTokensFromHeaders: saving new refresh token");
              return [4, (0, fetch_1.setToken)("refresh", refreshToken)];
            case 1:
              _a.sent();
              _a.label = 2;
            case 2:
              accessToken = headers.get("st-access-token");
              if (!(accessToken !== null))
                return [3, 4];
              (0, logger_1.logDebugMessage)("saveTokensFromHeaders: saving new access token");
              return [4, (0, fetch_1.setToken)("access", accessToken)];
            case 3:
              _a.sent();
              _a.label = 4;
            case 4:
              frontToken = headers.get("front-token");
              if (!(frontToken !== null))
                return [3, 6];
              (0, logger_1.logDebugMessage)("saveTokensFromHeaders: Setting sFrontToken: " + frontToken);
              return [4, fetch_1.FrontToken.setItem(frontToken)];
            case 5:
              _a.sent();
              _a.label = 6;
            case 6:
              antiCsrfToken = headers.get("anti-csrf");
              if (!(antiCsrfToken !== null))
                return [3, 9];
              return [4, (0, fetch_1.getLocalSessionState)(true)];
            case 7:
              tok = _a.sent();
              if (!(tok.status === "EXISTS"))
                return [3, 9];
              (0, logger_1.logDebugMessage)("saveTokensFromHeaders: Setting anti-csrf token");
              return [4, fetch_1.AntiCsrfToken.setItem(tok.lastAccessTokenUpdate, antiCsrfToken)];
            case 8:
              _a.sent();
              _a.label = 9;
            case 9:
              return [2];
          }
        });
      });
    }
    function getResponseHeadersFromXHR(xhr) {
      return new Headers(
        xhr.getAllResponseHeaders().split("\r\n").map(function(line) {
          var sep = line.indexOf(": ");
          if (sep === -1) {
            return ["", ""];
          }
          return [line.slice(0, sep), line.slice(sep + 2)];
        }).filter(function(e) {
          return e[0].length !== 0;
        })
      );
    }
  }
});

// node_modules/supertokens-website/lib/build/recipeImplementation.js
var require_recipeImplementation2 = __commonJS({
  "node_modules/supertokens-website/lib/build/recipeImplementation.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fetch_1 = require_fetch();
    var axios_1 = require_axios();
    var version_1 = require_version();
    var logger_1 = require_logger();
    var error_1 = require_error();
    var xmlhttprequest_1 = require_xmlhttprequest();
    var utils_1 = require_utils();
    function RecipeImplementation(recipeImplInput) {
      return {
        addXMLHttpRequestInterceptor: function(_) {
          (0, logger_1.logDebugMessage)("addXMLHttpRequestInterceptorAndReturnModified: called");
          (0, xmlhttprequest_1.addInterceptorsToXMLHttpRequest)();
        },
        addFetchInterceptorsAndReturnModifiedFetch: function(input) {
          (0, logger_1.logDebugMessage)("addFetchInterceptorsAndReturnModifiedFetch: called");
          return function(url, config) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [
                      4,
                      fetch_1.default.doRequest(
                        function(config2) {
                          return input.originalFetch(
                            typeof url === "object" && "clone" in url ? url.clone() : url,
                            __assign({}, config2)
                          );
                        },
                        config,
                        url
                      )
                    ];
                  case 1:
                    return [2, _a.sent()];
                }
              });
            });
          };
        },
        addAxiosInterceptors: function(input) {
          (0, logger_1.logDebugMessage)("addAxiosInterceptors: called");
          if (XMLHttpRequest.__interceptedBySuperTokens) {
            console.warn(
              "Not adding axios interceptor since XMLHttpRequest is already added. This is just a warning."
            );
            console.warn("Our axios and XMLHttpRequest interceptors cannot be used at the same time.");
            console.warn(
              "Since XMLHttpRequest is added automatically and supports axios by default, you can just remove addAxiosInterceptors from your code."
            );
            console.warn(
              "If you want to continue using our axios interceptor, you can override addXMLHttpRequestInterceptor with an empty function."
            );
            (0, logger_1.logDebugMessage)(
              "addAxiosInterceptors: not adding, because XHR interceptors are already in place"
            );
            return;
          }
          var requestInterceptors = input.axiosInstance.interceptors.request;
          for (var i = 0; i < requestInterceptors.handlers.length; i++) {
            if (requestInterceptors.handlers[i].fulfilled === axios_1.interceptorFunctionRequestFulfilled) {
              (0, logger_1.logDebugMessage)(
                "addAxiosInterceptors: not adding because already added on this instance"
              );
              return;
            }
          }
          input.axiosInstance.interceptors.request.use(axios_1.interceptorFunctionRequestFulfilled, function(error) {
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a) {
                throw error;
              });
            });
          });
          input.axiosInstance.interceptors.response.use(
            (0, axios_1.responseInterceptor)(input.axiosInstance),
            (0, axios_1.responseErrorInterceptor)(input.axiosInstance)
          );
        },
        getUserId: function(_) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenInfo;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  (0, logger_1.logDebugMessage)("getUserId: called");
                  return [4, fetch_1.FrontToken.getTokenInfo()];
                case 1:
                  tokenInfo = _a.sent();
                  if (tokenInfo === void 0) {
                    throw new Error("No session exists");
                  }
                  (0, logger_1.logDebugMessage)("getUserId: returning: " + tokenInfo.uid);
                  return [2, tokenInfo.uid];
              }
            });
          });
        },
        getAccessTokenPayloadSecurely: function(input) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenInfo, retry;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  (0, logger_1.logDebugMessage)("getAccessTokenPayloadSecurely: called");
                  return [4, fetch_1.FrontToken.getTokenInfo()];
                case 1:
                  tokenInfo = _a.sent();
                  if (tokenInfo === void 0) {
                    throw new Error("No session exists");
                  }
                  if (!(tokenInfo.ate < Date.now()))
                    return [3, 5];
                  (0, logger_1.logDebugMessage)("getAccessTokenPayloadSecurely: access token expired. Refreshing session");
                  return [4, fetch_1.default.attemptRefreshingSession()];
                case 2:
                  retry = _a.sent();
                  if (!retry)
                    return [3, 4];
                  return [
                    4,
                    this.getAccessTokenPayloadSecurely({
                      userContext: input.userContext
                    })
                  ];
                case 3:
                  return [2, _a.sent()];
                case 4:
                  throw new Error("Could not refresh session");
                case 5:
                  (0, logger_1.logDebugMessage)("getAccessTokenPayloadSecurely: returning: " + JSON.stringify(tokenInfo.up));
                  return [2, tokenInfo.up];
              }
            });
          });
        },
        doesSessionExist: function(_) {
          return __awaiter(this, void 0, void 0, function() {
            var tokenInfo, preRequestLSS, refresh;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  (0, logger_1.logDebugMessage)("doesSessionExist: called");
                  return [4, fetch_1.FrontToken.getTokenInfo()];
                case 1:
                  tokenInfo = _a.sent();
                  if (tokenInfo === void 0) {
                    (0, logger_1.logDebugMessage)("doesSessionExist: access token does not exist locally");
                    return [2, false];
                  }
                  if (!(tokenInfo.ate < Date.now()))
                    return [3, 4];
                  (0, logger_1.logDebugMessage)("doesSessionExist: access token expired. Refreshing session");
                  return [4, (0, fetch_1.getLocalSessionState)(false)];
                case 2:
                  preRequestLSS = _a.sent();
                  return [4, (0, fetch_1.onUnauthorisedResponse)(preRequestLSS)];
                case 3:
                  refresh = _a.sent();
                  return [2, refresh.result === "RETRY"];
                case 4:
                  return [2, true];
              }
            });
          });
        },
        signOut: function(input) {
          return __awaiter(this, void 0, void 0, function() {
            var preAPIResult, resp, responseJson, message;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  (0, logger_1.logDebugMessage)("signOut: called");
                  return [4, this.doesSessionExist(input)];
                case 1:
                  if (!_a.sent()) {
                    (0, logger_1.logDebugMessage)("signOut: exiting early because session does not exist");
                    (0, logger_1.logDebugMessage)("signOut: firing SIGN_OUT event");
                    recipeImplInput.onHandleEvent({
                      action: "SIGN_OUT",
                      userContext: input.userContext
                    });
                    return [2];
                  }
                  (0, logger_1.logDebugMessage)("signOut: Calling refresh pre API hook");
                  return [
                    4,
                    recipeImplInput.preAPIHook({
                      action: "SIGN_OUT",
                      requestInit: {
                        method: "post",
                        headers: {
                          "fdi-version": version_1.supported_fdi.join(","),
                          rid: fetch_1.default.rid
                        }
                      },
                      url: fetch_1.default.signOutUrl,
                      userContext: input.userContext
                    })
                  ];
                case 2:
                  preAPIResult = _a.sent();
                  (0, logger_1.logDebugMessage)("signOut: Calling API");
                  return [4, fetch(preAPIResult.url, preAPIResult.requestInit)];
                case 3:
                  resp = _a.sent();
                  (0, logger_1.logDebugMessage)("signOut: API ended");
                  (0, logger_1.logDebugMessage)("signOut: API responded with status code: " + resp.status);
                  if (resp.status === recipeImplInput.sessionExpiredStatusCode) {
                    return [2];
                  }
                  if (resp.status >= 300) {
                    throw resp;
                  }
                  return [
                    4,
                    recipeImplInput.postAPIHook({
                      action: "SIGN_OUT",
                      requestInit: preAPIResult.requestInit,
                      url: preAPIResult.url,
                      fetchResponse: resp.clone(),
                      userContext: input.userContext
                    })
                  ];
                case 4:
                  _a.sent();
                  return [4, resp.clone().json()];
                case 5:
                  responseJson = _a.sent();
                  if (responseJson.status === "GENERAL_ERROR") {
                    (0, logger_1.logDebugMessage)("doRequest: Throwing general error");
                    message = responseJson.message === void 0 ? "No Error Message Provided" : responseJson.message;
                    throw new error_1.STGeneralError(message);
                  }
                  return [2];
              }
            });
          });
        },
        getInvalidClaimsFromResponse: function(input) {
          return __awaiter(this, void 0, void 0, function() {
            var body;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!("body" in input.response))
                    return [3, 2];
                  return [4, input.response.clone().json()];
                case 1:
                  body = _a.sent();
                  return [3, 3];
                case 2:
                  if (typeof input.response.data === "string") {
                    body = JSON.parse(input.response.data);
                  } else {
                    body = input.response.data;
                  }
                  _a.label = 3;
                case 3:
                  return [2, body.claimValidationErrors];
              }
            });
          });
        },
        getGlobalClaimValidators: function(input) {
          return input.claimValidatorsAddedByOtherRecipes;
        },
        validateClaims: function(input) {
          return __awaiter(this, void 0, void 0, function() {
            var accessTokenPayload, _i, _a, validator, err_1, errors, _b, _c, validator, validationRes;
            return __generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  return [
                    4,
                    this.getAccessTokenPayloadSecurely({ userContext: input.userContext })
                  ];
                case 1:
                  accessTokenPayload = _d.sent();
                  _i = 0, _a = input.claimValidators;
                  _d.label = 2;
                case 2:
                  if (!(_i < _a.length))
                    return [3, 10];
                  validator = _a[_i];
                  return [4, validator.shouldRefresh(accessTokenPayload, input.userContext)];
                case 3:
                  if (!_d.sent())
                    return [3, 9];
                  _d.label = 4;
                case 4:
                  _d.trys.push([4, 6, , 7]);
                  return [4, validator.refresh(input.userContext)];
                case 5:
                  _d.sent();
                  return [3, 7];
                case 6:
                  err_1 = _d.sent();
                  console.error(
                    "Encountered an error while refreshing validator ".concat(validator.id),
                    err_1
                  );
                  return [3, 7];
                case 7:
                  return [
                    4,
                    this.getAccessTokenPayloadSecurely({ userContext: input.userContext })
                  ];
                case 8:
                  accessTokenPayload = _d.sent();
                  _d.label = 9;
                case 9:
                  _i++;
                  return [3, 2];
                case 10:
                  errors = [];
                  _b = 0, _c = input.claimValidators;
                  _d.label = 11;
                case 11:
                  if (!(_b < _c.length))
                    return [3, 14];
                  validator = _c[_b];
                  return [4, validator.validate(accessTokenPayload, input.userContext)];
                case 12:
                  validationRes = _d.sent();
                  if (!validationRes.isValid) {
                    errors.push({
                      validatorId: validator.id,
                      reason: validationRes.reason
                    });
                  }
                  _d.label = 13;
                case 13:
                  _b++;
                  return [3, 11];
                case 14:
                  return [2, errors];
              }
            });
          });
        },
        shouldDoInterceptionBasedOnUrl: function(toCheckUrl, apiDomain, sessionTokenBackendDomain) {
          (0, logger_1.logDebugMessage)(
            "shouldDoInterceptionBasedOnUrl: toCheckUrl: " + toCheckUrl + " apiDomain: " + apiDomain + " sessionTokenBackendDomain: " + sessionTokenBackendDomain
          );
          function isNumeric(str) {
            if (typeof str != "string")
              return false;
            return !isNaN(str) && !isNaN(parseFloat(str));
          }
          if (toCheckUrl.includes("superTokensDoNotDoInterception")) {
            return false;
          }
          toCheckUrl = (0, utils_1.normaliseURLDomainOrThrowError)(toCheckUrl);
          var urlObj = new URL(toCheckUrl);
          var domain = urlObj.hostname;
          if (sessionTokenBackendDomain === void 0) {
            domain = urlObj.port === "" ? domain : domain + ":" + urlObj.port;
            apiDomain = (0, utils_1.normaliseURLDomainOrThrowError)(apiDomain);
            var apiUrlObj = new URL(apiDomain);
            return domain === (apiUrlObj.port === "" ? apiUrlObj.hostname : apiUrlObj.hostname + ":" + apiUrlObj.port);
          } else {
            var normalisedsessionDomain = (0, utils_1.normaliseSessionScopeOrThrowError)(sessionTokenBackendDomain);
            if (sessionTokenBackendDomain.split(":").length > 1) {
              var portStr = sessionTokenBackendDomain.split(":")[sessionTokenBackendDomain.split(":").length - 1];
              if (isNumeric(portStr)) {
                normalisedsessionDomain += ":" + portStr;
                domain = urlObj.port === "" ? domain : domain + ":" + urlObj.port;
              }
            }
            if (sessionTokenBackendDomain.startsWith(".")) {
              return ("." + domain).endsWith(normalisedsessionDomain);
            } else {
              return domain === normalisedsessionDomain;
            }
          }
        }
      };
    }
    exports.default = RecipeImplementation;
  }
});

// node_modules/supertokens-website/lib/build/claims/primitiveClaim.js
var require_primitiveClaim = __commonJS({
  "node_modules/supertokens-website/lib/build/claims/primitiveClaim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrimitiveClaim = void 0;
    var PrimitiveClaim = function() {
      function PrimitiveClaim2(config) {
        var _this = this;
        this.validators = {
          hasValue: function(val, maxAgeInSeconds, id) {
            if (maxAgeInSeconds === void 0) {
              maxAgeInSeconds = _this.defaultMaxAgeInSeconds;
            }
            return {
              id: id !== void 0 ? id : _this.id,
              refresh: function(ctx) {
                return _this.refresh(ctx);
              },
              shouldRefresh: function(payload, ctx) {
                return _this.getValueFromPayload(payload, ctx) === void 0 || maxAgeInSeconds !== void 0 && payload[_this.id].t < Date.now() - maxAgeInSeconds * 1e3;
              },
              validate: function(payload, ctx) {
                var claimVal = _this.getValueFromPayload(payload, ctx);
                if (claimVal === void 0) {
                  return {
                    isValid: false,
                    reason: { message: "value does not exist", expectedValue: val, actualValue: claimVal }
                  };
                }
                var ageInSeconds = (Date.now() - _this.getLastFetchedTime(payload, ctx)) / 1e3;
                if (maxAgeInSeconds !== void 0 && ageInSeconds > maxAgeInSeconds) {
                  return {
                    isValid: false,
                    reason: {
                      message: "expired",
                      ageInSeconds,
                      maxAgeInSeconds
                    }
                  };
                }
                if (claimVal !== val) {
                  return {
                    isValid: false,
                    reason: { message: "wrong value", expectedValue: val, actualValue: claimVal }
                  };
                }
                return { isValid: true };
              }
            };
          }
        };
        this.id = config.id;
        this.refresh = config.refresh;
        this.defaultMaxAgeInSeconds = config.defaultMaxAgeInSeconds;
      }
      PrimitiveClaim2.prototype.getValueFromPayload = function(payload, _userContext) {
        return payload[this.id] !== void 0 ? payload[this.id].v : void 0;
      };
      PrimitiveClaim2.prototype.getLastFetchedTime = function(payload, _userContext) {
        return payload[this.id] !== void 0 ? payload[this.id].t : void 0;
      };
      return PrimitiveClaim2;
    }();
    exports.PrimitiveClaim = PrimitiveClaim;
  }
});

// node_modules/supertokens-website/lib/build/claims/primitiveArrayClaim.js
var require_primitiveArrayClaim = __commonJS({
  "node_modules/supertokens-website/lib/build/claims/primitiveArrayClaim.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrimitiveArrayClaim = void 0;
    var PrimitiveArrayClaim = function() {
      function PrimitiveArrayClaim2(config) {
        var _this = this;
        this.validators = {
          includes: function(val, maxAgeInSeconds, id) {
            if (maxAgeInSeconds === void 0) {
              maxAgeInSeconds = _this.defaultMaxAgeInSeconds;
            }
            return {
              id: id !== void 0 ? id : _this.id,
              refresh: function(ctx) {
                return _this.refresh(ctx);
              },
              shouldRefresh: function(payload, ctx) {
                return _this.getValueFromPayload(payload, ctx) === void 0 || maxAgeInSeconds !== void 0 && payload[_this.id].t < Date.now() - maxAgeInSeconds * 1e3;
              },
              validate: function(payload, ctx) {
                return __awaiter(_this, void 0, void 0, function() {
                  var claimVal, ageInSeconds;
                  return __generator(this, function(_a) {
                    claimVal = this.getValueFromPayload(payload, ctx);
                    if (claimVal === void 0) {
                      return [
                        2,
                        {
                          isValid: false,
                          reason: {
                            message: "value does not exist",
                            expectedToInclude: val,
                            actualValue: claimVal
                          }
                        }
                      ];
                    }
                    ageInSeconds = (Date.now() - this.getLastFetchedTime(payload, ctx)) / 1e3;
                    if (maxAgeInSeconds !== void 0 && ageInSeconds > maxAgeInSeconds) {
                      return [
                        2,
                        {
                          isValid: false,
                          reason: {
                            message: "expired",
                            ageInSeconds,
                            maxAgeInSeconds
                          }
                        }
                      ];
                    }
                    if (!claimVal.includes(val)) {
                      return [
                        2,
                        {
                          isValid: false,
                          reason: {
                            message: "wrong value",
                            expectedToInclude: val,
                            actualValue: claimVal
                          }
                        }
                      ];
                    }
                    return [2, { isValid: true }];
                  });
                });
              }
            };
          },
          excludes: function(val, maxAgeInSeconds, id) {
            if (maxAgeInSeconds === void 0) {
              maxAgeInSeconds = _this.defaultMaxAgeInSeconds;
            }
            return {
              id: id !== void 0 ? id : _this.id,
              refresh: function(ctx) {
                return _this.refresh(ctx);
              },
              shouldRefresh: function(payload, ctx) {
                return _this.getValueFromPayload(payload, ctx) === void 0 || maxAgeInSeconds !== void 0 && payload[_this.id].t < Date.now() - maxAgeInSeconds * 1e3;
              },
              validate: function(payload, ctx) {
                return __awaiter(_this, void 0, void 0, function() {
                  var claimVal, ageInSeconds;
                  return __generator(this, function(_a) {
                    claimVal = this.getValueFromPayload(payload, ctx);
                    if (claimVal === void 0) {
                      return [
                        2,
                        {
                          isValid: false,
                          reason: {
                            message: "value does not exist",
                            expectedToNotInclude: val,
                            actualValue: claimVal
                          }
                        }
                      ];
                    }
                    ageInSeconds = (Date.now() - this.getLastFetchedTime(payload, ctx)) / 1e3;
                    if (maxAgeInSeconds !== void 0 && ageInSeconds > maxAgeInSeconds) {
                      return [
                        2,
                        {
                          isValid: false,
                          reason: {
                            message: "expired",
                            ageInSeconds,
                            maxAgeInSeconds
                          }
                        }
                      ];
                    }
                    if (claimVal.includes(val)) {
                      return [
                        2,
                        {
                          isValid: false,
                          reason: {
                            message: "wrong value",
                            expectedToNotInclude: val,
                            actualValue: claimVal
                          }
                        }
                      ];
                    }
                    return [2, { isValid: true }];
                  });
                });
              }
            };
          },
          includesAll: function(val, maxAgeInSeconds, id) {
            if (maxAgeInSeconds === void 0) {
              maxAgeInSeconds = _this.defaultMaxAgeInSeconds;
            }
            return {
              id: id !== void 0 ? id : _this.id,
              refresh: function(ctx) {
                return _this.refresh(ctx);
              },
              shouldRefresh: function(payload, ctx) {
                return _this.getValueFromPayload(payload, ctx) === void 0 || maxAgeInSeconds !== void 0 && payload[_this.id].t < Date.now() - maxAgeInSeconds * 1e3;
              },
              validate: function(payload, ctx) {
                return __awaiter(_this, void 0, void 0, function() {
                  var claimVal, ageInSeconds, claimSet, isValid;
                  return __generator(this, function(_a) {
                    claimVal = this.getValueFromPayload(payload, ctx);
                    if (claimVal === void 0) {
                      return [
                        2,
                        {
                          isValid: false,
                          reason: {
                            message: "value does not exist",
                            expectedToInclude: val,
                            actualValue: claimVal
                          }
                        }
                      ];
                    }
                    ageInSeconds = (Date.now() - this.getLastFetchedTime(payload, ctx)) / 1e3;
                    if (maxAgeInSeconds !== void 0 && ageInSeconds > maxAgeInSeconds) {
                      return [
                        2,
                        {
                          isValid: false,
                          reason: {
                            message: "expired",
                            ageInSeconds,
                            maxAgeInSeconds
                          }
                        }
                      ];
                    }
                    claimSet = new Set(claimVal);
                    isValid = val.every(function(v) {
                      return claimSet.has(v);
                    });
                    return [
                      2,
                      isValid ? { isValid } : {
                        isValid,
                        reason: {
                          message: "wrong value",
                          expectedToInclude: val,
                          actualValue: claimVal
                        }
                      }
                    ];
                  });
                });
              }
            };
          },
          includesAny: function(val, maxAgeInSeconds, id) {
            if (maxAgeInSeconds === void 0) {
              maxAgeInSeconds = _this.defaultMaxAgeInSeconds;
            }
            return {
              id: id !== void 0 ? id : _this.id,
              refresh: function(ctx) {
                return _this.refresh(ctx);
              },
              shouldRefresh: function(payload, ctx) {
                return _this.getValueFromPayload(payload, ctx) === void 0 || maxAgeInSeconds !== void 0 && payload[_this.id].t < Date.now() - maxAgeInSeconds * 1e3;
              },
              validate: function(payload, ctx) {
                return __awaiter(_this, void 0, void 0, function() {
                  var claimVal, ageInSeconds, claimSet, isValid;
                  return __generator(this, function(_a) {
                    claimVal = this.getValueFromPayload(payload, ctx);
                    if (claimVal === void 0) {
                      return [
                        2,
                        {
                          isValid: false,
                          reason: {
                            message: "value does not exist",
                            expectedToInclude: val,
                            actualValue: claimVal
                          }
                        }
                      ];
                    }
                    ageInSeconds = (Date.now() - this.getLastFetchedTime(payload, ctx)) / 1e3;
                    if (maxAgeInSeconds !== void 0 && ageInSeconds > maxAgeInSeconds) {
                      return [
                        2,
                        {
                          isValid: false,
                          reason: {
                            message: "expired",
                            ageInSeconds,
                            maxAgeInSeconds
                          }
                        }
                      ];
                    }
                    claimSet = new Set(claimVal);
                    isValid = val.some(function(v) {
                      return claimSet.has(v);
                    });
                    return [
                      2,
                      isValid ? { isValid } : {
                        isValid,
                        reason: {
                          message: "wrong value",
                          expectedToIncludeAtLeastOneOf: val,
                          actualValue: claimVal
                        }
                      }
                    ];
                  });
                });
              }
            };
          },
          excludesAll: function(val, maxAgeInSeconds, id) {
            if (maxAgeInSeconds === void 0) {
              maxAgeInSeconds = _this.defaultMaxAgeInSeconds;
            }
            return {
              id: id !== void 0 ? id : _this.id,
              refresh: function(ctx) {
                return _this.refresh(ctx);
              },
              shouldRefresh: function(payload, ctx) {
                return _this.getValueFromPayload(payload, ctx) === void 0 || maxAgeInSeconds !== void 0 && payload[_this.id].t < Date.now() - maxAgeInSeconds * 1e3;
              },
              validate: function(payload, ctx) {
                return __awaiter(_this, void 0, void 0, function() {
                  var claimVal, ageInSeconds, claimSet, isValid;
                  return __generator(this, function(_a) {
                    claimVal = this.getValueFromPayload(payload, ctx);
                    if (claimVal === void 0) {
                      return [
                        2,
                        {
                          isValid: false,
                          reason: {
                            message: "value does not exist",
                            expectedToNotInclude: val,
                            actualValue: claimVal
                          }
                        }
                      ];
                    }
                    ageInSeconds = (Date.now() - this.getLastFetchedTime(payload, ctx)) / 1e3;
                    if (maxAgeInSeconds !== void 0 && ageInSeconds > maxAgeInSeconds) {
                      return [
                        2,
                        {
                          isValid: false,
                          reason: {
                            message: "expired",
                            ageInSeconds,
                            maxAgeInSeconds
                          }
                        }
                      ];
                    }
                    claimSet = new Set(claimVal);
                    isValid = val.every(function(v) {
                      return !claimSet.has(v);
                    });
                    return [
                      2,
                      isValid ? { isValid } : {
                        isValid,
                        reason: {
                          message: "wrong value",
                          expectedToNotInclude: val,
                          actualValue: claimVal
                        }
                      }
                    ];
                  });
                });
              }
            };
          }
        };
        this.id = config.id;
        this.refresh = config.refresh;
        this.defaultMaxAgeInSeconds = config.defaultMaxAgeInSeconds;
      }
      PrimitiveArrayClaim2.prototype.getValueFromPayload = function(payload, _userContext) {
        return payload[this.id] !== void 0 ? payload[this.id].v : void 0;
      };
      PrimitiveArrayClaim2.prototype.getLastFetchedTime = function(payload, _userContext) {
        return payload[this.id] !== void 0 ? payload[this.id].t : void 0;
      };
      return PrimitiveArrayClaim2;
    }();
    exports.PrimitiveArrayClaim = PrimitiveArrayClaim;
  }
});

// node_modules/supertokens-website/lib/build/claims/booleanClaim.js
var require_booleanClaim = __commonJS({
  "node_modules/supertokens-website/lib/build/claims/booleanClaim.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BooleanClaim = void 0;
    var primitiveClaim_1 = require_primitiveClaim();
    var BooleanClaim = function(_super) {
      __extends(BooleanClaim2, _super);
      function BooleanClaim2(config) {
        var _this = _super.call(this, config) || this;
        _this.validators = __assign(__assign({}, _this.validators), {
          isTrue: function(maxAge) {
            return _this.validators.hasValue(true, maxAge);
          },
          isFalse: function(maxAge) {
            return _this.validators.hasValue(false, maxAge);
          }
        });
        return _this;
      }
      return BooleanClaim2;
    }(primitiveClaim_1.PrimitiveClaim);
    exports.BooleanClaim = BooleanClaim;
  }
});

// node_modules/supertokens-website/lib/build/index.js
var require_build2 = __commonJS({
  "node_modules/supertokens-website/lib/build/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BooleanClaim = exports.PrimitiveArrayClaim = exports.PrimitiveClaim = exports.getInvalidClaimsFromResponse = exports.getClaimValue = exports.validateClaims = exports.signOut = exports.addAxiosInterceptors = exports.doesSessionExist = exports.attemptRefreshingSession = exports.getAccessToken = exports.getAccessTokenPayloadSecurely = exports.getUserId = exports.init = void 0;
    var fetch_1 = require_fetch();
    var recipeImplementation_1 = require_recipeImplementation2();
    var supertokens_js_override_1 = require_build();
    var utils_1 = require_utils();
    var cookieHandler_1 = require_cookieHandler();
    var windowHandler_1 = require_windowHandler();
    var lockFactory_1 = require_lockFactory();
    var sessionClaimValidatorStore_1 = require_sessionClaimValidatorStore();
    var AuthHttpRequest = function() {
      function AuthHttpRequest2() {
      }
      AuthHttpRequest2.init = function(options) {
        cookieHandler_1.default.init(options.cookieHandler);
        windowHandler_1.default.init(options.windowHandler);
        lockFactory_1.default.init(
          options.lockFactory,
          windowHandler_1.default.getReferenceOrThrow().windowHandler.localStorage
        );
        var config = (0, utils_1.validateAndNormaliseInputOrThrowError)(options);
        var recipeImpl = new supertokens_js_override_1.default(
          (0, recipeImplementation_1.default)({
            onHandleEvent: config.onHandleEvent,
            preAPIHook: config.preAPIHook,
            postAPIHook: config.postAPIHook,
            sessionExpiredStatusCode: config.sessionExpiredStatusCode
          })
        ).override(config.override.functions).build();
        fetch_1.default.init(config, recipeImpl);
        AuthHttpRequest2.axiosInterceptorQueue.forEach(function(f) {
          f();
        });
        AuthHttpRequest2.axiosInterceptorQueue = [];
      };
      AuthHttpRequest2.getUserId = function(input) {
        return fetch_1.default.recipeImpl.getUserId({
          userContext: (0, utils_1.getNormalisedUserContext)(input === void 0 ? void 0 : input.userContext)
        });
      };
      AuthHttpRequest2.getAccessTokenPayloadSecurely = function(input) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_b) {
            return [
              2,
              fetch_1.default.recipeImpl.getAccessTokenPayloadSecurely({
                userContext: (0, utils_1.getNormalisedUserContext)(
                  input === void 0 ? void 0 : input.userContext
                )
              })
            ];
          });
        });
      };
      var _a;
      _a = AuthHttpRequest2;
      AuthHttpRequest2.axiosInterceptorQueue = [];
      AuthHttpRequest2.attemptRefreshingSession = function() {
        return __awaiter(void 0, void 0, void 0, function() {
          return __generator(_a, function(_b) {
            return [2, fetch_1.default.attemptRefreshingSession()];
          });
        });
      };
      AuthHttpRequest2.doesSessionExist = function(input) {
        return fetch_1.default.recipeImpl.doesSessionExist({
          userContext: (0, utils_1.getNormalisedUserContext)(input === void 0 ? void 0 : input.userContext)
        });
      };
      AuthHttpRequest2.addAxiosInterceptors = function(axiosInstance, userContext) {
        if (!fetch_1.default.initCalled) {
          AuthHttpRequest2.axiosInterceptorQueue.push(function() {
            fetch_1.default.recipeImpl.addAxiosInterceptors({
              axiosInstance,
              userContext: (0, utils_1.getNormalisedUserContext)(userContext)
            });
          });
        } else {
          fetch_1.default.recipeImpl.addAxiosInterceptors({
            axiosInstance,
            userContext: (0, utils_1.getNormalisedUserContext)(userContext)
          });
        }
      };
      AuthHttpRequest2.signOut = function(input) {
        return fetch_1.default.recipeImpl.signOut({
          userContext: (0, utils_1.getNormalisedUserContext)(input === void 0 ? void 0 : input.userContext)
        });
      };
      AuthHttpRequest2.getInvalidClaimsFromResponse = function(input) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_b) {
            return [
              2,
              fetch_1.default.recipeImpl.getInvalidClaimsFromResponse({
                response: input.response,
                userContext: (0, utils_1.getNormalisedUserContext)(input.userContext)
              })
            ];
          });
        });
      };
      AuthHttpRequest2.getClaimValue = function(input) {
        return __awaiter(this, void 0, void 0, function() {
          var userContext, accessTokenPayload;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                userContext = (0, utils_1.getNormalisedUserContext)(
                  input === void 0 ? void 0 : input.userContext
                );
                return [
                  4,
                  AuthHttpRequest2.getAccessTokenPayloadSecurely({ userContext })
                ];
              case 1:
                accessTokenPayload = _b.sent();
                return [2, input.claim.getValueFromPayload(accessTokenPayload, userContext)];
            }
          });
        });
      };
      AuthHttpRequest2.validateClaims = function(overrideGlobalClaimValidators, userContext) {
        var normalisedUserContext = (0, utils_1.getNormalisedUserContext)(userContext);
        var claimValidatorsAddedByOtherRecipes = sessionClaimValidatorStore_1.SessionClaimValidatorStore.getClaimValidatorsAddedByOtherRecipes();
        var globalClaimValidators = fetch_1.default.recipeImpl.getGlobalClaimValidators({
          claimValidatorsAddedByOtherRecipes,
          userContext: normalisedUserContext
        });
        var claimValidators = overrideGlobalClaimValidators !== void 0 ? overrideGlobalClaimValidators(globalClaimValidators, normalisedUserContext) : globalClaimValidators;
        if (claimValidators.length === 0) {
          return [];
        }
        return fetch_1.default.recipeImpl.validateClaims({
          claimValidators,
          userContext: (0, utils_1.getNormalisedUserContext)(userContext)
        });
      };
      AuthHttpRequest2.getAccessToken = function(input) {
        return __awaiter(void 0, void 0, void 0, function() {
          return __generator(_a, function(_b) {
            switch (_b.label) {
              case 0:
                return [
                  4,
                  fetch_1.default.recipeImpl.doesSessionExist({
                    userContext: (0, utils_1.getNormalisedUserContext)(
                      input === void 0 ? void 0 : input.userContext
                    )
                  })
                ];
              case 1:
                if (_b.sent()) {
                  return [2, (0, fetch_1.getTokenForHeaderAuth)("access")];
                }
                return [2, void 0];
            }
          });
        });
      };
      return AuthHttpRequest2;
    }();
    exports.default = AuthHttpRequest;
    exports.init = AuthHttpRequest.init;
    exports.getUserId = AuthHttpRequest.getUserId;
    exports.getAccessTokenPayloadSecurely = AuthHttpRequest.getAccessTokenPayloadSecurely;
    exports.getAccessToken = AuthHttpRequest.getAccessToken;
    exports.attemptRefreshingSession = AuthHttpRequest.attemptRefreshingSession;
    exports.doesSessionExist = AuthHttpRequest.doesSessionExist;
    exports.addAxiosInterceptors = AuthHttpRequest.addAxiosInterceptors;
    exports.signOut = AuthHttpRequest.signOut;
    exports.validateClaims = AuthHttpRequest.validateClaims;
    exports.getClaimValue = AuthHttpRequest.getClaimValue;
    exports.getInvalidClaimsFromResponse = AuthHttpRequest.getInvalidClaimsFromResponse;
    var primitiveClaim_1 = require_primitiveClaim();
    Object.defineProperty(exports, "PrimitiveClaim", {
      enumerable: true,
      get: function() {
        return primitiveClaim_1.PrimitiveClaim;
      }
    });
    var primitiveArrayClaim_1 = require_primitiveArrayClaim();
    Object.defineProperty(exports, "PrimitiveArrayClaim", {
      enumerable: true,
      get: function() {
        return primitiveArrayClaim_1.PrimitiveArrayClaim;
      }
    });
    var booleanClaim_1 = require_booleanClaim();
    Object.defineProperty(exports, "BooleanClaim", {
      enumerable: true,
      get: function() {
        return booleanClaim_1.BooleanClaim;
      }
    });
  }
});

// node_modules/supertokens-website/index.js
var require_supertokens_website = __commonJS({
  "node_modules/supertokens-website/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    __export(require_build2());
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/session/recipe.js
var require_recipe = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/session/recipe.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Recipe = void 0;
    var recipeModule_1 = require_recipeModule();
    var supertokens_website_1 = require_supertokens_website();
    var utils_1 = require_utils2();
    var Recipe = function(_super) {
      __extends(Recipe2, _super);
      function Recipe2(config) {
        var _this = _super.call(this, config) || this;
        _this.getUserId = function(input) {
          return supertokens_website_1.default.getUserId({
            userContext: input.userContext
          });
        };
        _this.getAccessToken = function(input) {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [
                2,
                supertokens_website_1.default.getAccessToken({
                  userContext: input.userContext
                })
              ];
            });
          });
        };
        _this.getAccessTokenPayloadSecurely = function(input) {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [
                2,
                supertokens_website_1.default.getAccessTokenPayloadSecurely({
                  userContext: input.userContext
                })
              ];
            });
          });
        };
        _this.doesSessionExist = function(input) {
          return supertokens_website_1.default.doesSessionExist({
            userContext: input.userContext
          });
        };
        _this.signOut = function(input) {
          return supertokens_website_1.default.signOut({
            userContext: input.userContext
          });
        };
        _this.attemptRefreshingSession = function() {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, supertokens_website_1.default.attemptRefreshingSession()];
            });
          });
        };
        _this.validateClaims = function(input) {
          return supertokens_website_1.default.validateClaims(input.overrideGlobalClaimValidators, input.userContext);
        };
        supertokens_website_1.default.init(
          __assign(__assign({}, config), {
            preAPIHook: function(context) {
              return __awaiter(_this, void 0, void 0, function() {
                var headers, response;
                return __generator(this, function(_a) {
                  headers = new Headers(context.requestInit.headers);
                  headers.set("rid", config.recipeId);
                  response = __assign(__assign({}, context), {
                    requestInit: __assign(__assign({}, context.requestInit), { headers })
                  });
                  if (config.preAPIHook === void 0) {
                    return [2, response];
                  } else {
                    return [2, config.preAPIHook(context)];
                  }
                  return [2];
                });
              });
            },
            apiDomain: config.appInfo.apiDomain.getAsStringDangerous(),
            apiBasePath: config.appInfo.apiBasePath.getAsStringDangerous()
          })
        );
        return _this;
      }
      Recipe2.init = function(config) {
        return function(appInfo, _, enableDebugLogs) {
          Recipe2.instance = new Recipe2(
            __assign(__assign({}, config), {
              appInfo,
              recipeId: Recipe2.RECIPE_ID,
              enableDebugLogs
            })
          );
          return Recipe2.instance;
        };
      };
      Recipe2.prototype.getClaimValue = function(input) {
        return supertokens_website_1.default.getClaimValue(input);
      };
      Recipe2.prototype.getInvalidClaimsFromResponse = function(input) {
        return supertokens_website_1.default.getInvalidClaimsFromResponse(input);
      };
      Recipe2.addAxiosInterceptors = function(axiosInstance, userContext) {
        return supertokens_website_1.default.addAxiosInterceptors(axiosInstance, userContext);
      };
      Recipe2.getInstanceOrThrow = function() {
        if (Recipe2.instance === void 0) {
          var error = "No instance of Session found. Make sure to call the Session.init method.";
          error = (0, utils_1.checkForSSRErrorAndAppendIfNeeded)(error);
          throw Error(error);
        }
        return Recipe2.instance;
      };
      Recipe2.reset = function() {
        if (!(0, utils_1.isTest)()) {
          return;
        }
        Recipe2.instance = void 0;
        return;
      };
      Recipe2.RECIPE_ID = "session";
      return Recipe2;
    }(recipeModule_1.default);
    exports.Recipe = Recipe;
    exports.default = Recipe;
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/authRecipe/index.js
var require_authRecipe = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/authRecipe/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var recipeModule_1 = require_recipeModule();
    var recipe_1 = require_recipe();
    var AuthRecipe = function(_super) {
      __extends(AuthRecipe2, _super);
      function AuthRecipe2(config) {
        var _this = _super.call(this, config) || this;
        _this.signOut = function(input) {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [
                    4,
                    recipe_1.default.getInstanceOrThrow().signOut({
                      userContext: input.userContext
                    })
                  ];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        return _this;
      }
      return AuthRecipe2;
    }(recipeModule_1.default);
    exports.default = AuthRecipe;
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/multitenancy/recipe.js
var require_recipe2 = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/multitenancy/recipe.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Recipe = void 0;
    var utils_1 = require_utils5();
    var supertokens_js_override_1 = require_build();
    var recipeImplementation_1 = require_recipeImplementation();
    var utils_2 = require_utils2();
    var authRecipe_1 = require_authRecipe();
    var Recipe = function(_super) {
      __extends(Recipe2, _super);
      function Recipe2(config) {
        var _this = _super.call(this, (0, utils_1.normaliseUserInput)(config)) || this;
        var builder = new supertokens_js_override_1.default(
          (0, recipeImplementation_1.default)({
            recipeId: _this.config.recipeId,
            appInfo: _this.config.appInfo,
            clientType: _this.config.clientType,
            preAPIHook: _this.config.preAPIHook,
            postAPIHook: _this.config.postAPIHook
          })
        );
        _this.recipeImplementation = builder.override(_this.config.override.functions).build();
        return _this;
      }
      Recipe2.init = function(config) {
        return function(appInfo, clientType) {
          Recipe2.instance = new Recipe2(
            __assign(__assign({}, config), { recipeId: Recipe2.RECIPE_ID, appInfo, clientType })
          );
          return Recipe2.instance;
        };
      };
      Recipe2.getInstanceOrThrow = function() {
        if (Recipe2.instance === void 0) {
          var error = "No instance of Multitenancy found. Make sure to call the Multitenancy.init method.";
          error = (0, utils_2.checkForSSRErrorAndAppendIfNeeded)(error);
          throw Error(error);
        }
        return Recipe2.instance;
      };
      Recipe2.reset = function() {
        if (!(0, utils_2.isTest)()) {
          return;
        }
        Recipe2.instance = void 0;
        return;
      };
      Recipe2.RECIPE_ID = "multitenancy";
      return Recipe2;
    }(authRecipe_1.default);
    exports.Recipe = Recipe;
    exports.default = Recipe;
  }
});

// node_modules/supertokens-web-js/lib/build/supertokens.js
var require_supertokens = __commonJS({
  "node_modules/supertokens-web-js/lib/build/supertokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils2();
    var cookieHandler_1 = require_cookieHandler3();
    var windowHandler_1 = require_windowHandler3();
    var postSuperTokensInitCallbacks_1 = require_postSuperTokensInitCallbacks();
    var recipe_1 = require_recipe2();
    var SuperTokens = function() {
      function SuperTokens2(config) {
        var _this = this;
        this.recipeList = [];
        this.appInfo = (0, utils_1.normaliseInputAppInfoOrThrowError)(config.appInfo);
        if (config.recipeList === void 0 || config.recipeList.length === 0) {
          throw new Error(
            "Please provide at least one recipe to the supertokens.init function call. See https://supertokens.io/docs/emailpassword/quick-setup/frontend"
          );
        }
        var enableDebugLogs = false;
        if (config.enableDebugLogs !== void 0) {
          enableDebugLogs = config.enableDebugLogs;
        }
        var multitenancyFound = false;
        this.recipeList = config.recipeList.map(function(recipe) {
          var recipeInstance = recipe(_this.appInfo, config.clientType, enableDebugLogs);
          if (recipeInstance.config.recipeId === recipe_1.Recipe.RECIPE_ID) {
            multitenancyFound = true;
          }
          return recipeInstance;
        });
        if (!multitenancyFound) {
          this.recipeList.push(recipe_1.Recipe.init()(this.appInfo, config.clientType, enableDebugLogs));
        }
      }
      SuperTokens2.init = function(config) {
        cookieHandler_1.CookieHandlerReference.init(config.cookieHandler);
        windowHandler_1.WindowHandlerReference.init(config.windowHandler);
        if (SuperTokens2.instance !== void 0) {
          console.warn("SuperTokens was already initialized");
          return;
        }
        SuperTokens2.instance = new SuperTokens2(config);
        postSuperTokensInitCallbacks_1.PostSuperTokensInitCallbacks.runPostInitCallbacks();
      };
      SuperTokens2.getInstanceOrThrow = function() {
        if (SuperTokens2.instance === void 0) {
          var error = "SuperTokens must be initialized before calling this method.";
          error = (0, utils_1.checkForSSRErrorAndAppendIfNeeded)(error);
          throw new Error(error);
        }
        return SuperTokens2.instance;
      };
      SuperTokens2.reset = function() {
        if (!(0, utils_1.isTest)()) {
          console.warn("Calling reset() is only supported during testing");
          return;
        }
        SuperTokens2.instance = void 0;
        return;
      };
      return SuperTokens2;
    }();
    exports.default = SuperTokens;
  }
});

// node_modules/supertokens-web-js/lib/build/index.js
var require_build3 = __commonJS({
  "node_modules/supertokens-web-js/lib/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.init = void 0;
    var supertokens_1 = require_supertokens();
    var SuperTokensAPIWrapper = function() {
      function SuperTokensAPIWrapper2() {
      }
      SuperTokensAPIWrapper2.init = function(config) {
        supertokens_1.default.init(config);
      };
      return SuperTokensAPIWrapper2;
    }();
    exports.default = SuperTokensAPIWrapper;
    exports.init = SuperTokensAPIWrapper.init;
  }
});

// node_modules/supertokens-web-js/index.js
var require_supertokens_web_js = __commonJS({
  "node_modules/supertokens-web-js/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    __export(require_build3());
  }
});

// node_modules/supertokens-web-js/utils/cookieHandler/index.js
var require_cookieHandler4 = __commonJS({
  "node_modules/supertokens-web-js/utils/cookieHandler/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    var d = require_cookieHandler3();
    if (d.default !== void 0) {
      __export(d);
    } else {
      __export({
        default: d,
        ...d
      });
    }
  }
});

// node_modules/supertokens-web-js/utils/postSuperTokensInitCallbacks.js
var require_postSuperTokensInitCallbacks2 = __commonJS({
  "node_modules/supertokens-web-js/utils/postSuperTokensInitCallbacks.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    __export(require_postSuperTokensInitCallbacks());
  }
});

// node_modules/supertokens-web-js/utils/windowHandler/index.js
var require_windowHandler4 = __commonJS({
  "node_modules/supertokens-web-js/utils/windowHandler/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    __export(require_windowHandler3());
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/session/index.js
var require_session = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/session/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getInvalidClaimsFromResponse = exports.getClaimValue = exports.validateClaims = exports.signOut = exports.addAxiosInterceptors = exports.doesSessionExist = exports.attemptRefreshingSession = exports.getAccessToken = exports.getAccessTokenPayloadSecurely = exports.getUserId = exports.init = exports.BooleanClaim = exports.PrimitiveArrayClaim = exports.PrimitiveClaim = void 0;
    var utils_1 = require_utils2();
    var recipe_1 = require_recipe();
    var RecipeWrapper = function() {
      function RecipeWrapper2() {
      }
      RecipeWrapper2.init = function(config) {
        return recipe_1.default.init(config);
      };
      RecipeWrapper2.getUserId = function(input) {
        return recipe_1.default.getInstanceOrThrow().getUserId({
          userContext: (0, utils_1.getNormalisedUserContext)(
            input === null || input === void 0 ? void 0 : input.userContext
          )
        });
      };
      RecipeWrapper2.getAccessToken = function(input) {
        return recipe_1.default.getInstanceOrThrow().getAccessToken({
          userContext: (0, utils_1.getNormalisedUserContext)(
            input === null || input === void 0 ? void 0 : input.userContext
          )
        });
      };
      RecipeWrapper2.getAccessTokenPayloadSecurely = function(input) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [
              2,
              recipe_1.default.getInstanceOrThrow().getAccessTokenPayloadSecurely({
                userContext: (0, utils_1.getNormalisedUserContext)(
                  input === null || input === void 0 ? void 0 : input.userContext
                )
              })
            ];
          });
        });
      };
      RecipeWrapper2.attemptRefreshingSession = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, recipe_1.default.getInstanceOrThrow().attemptRefreshingSession()];
          });
        });
      };
      RecipeWrapper2.doesSessionExist = function(input) {
        return recipe_1.default.getInstanceOrThrow().doesSessionExist({
          userContext: (0, utils_1.getNormalisedUserContext)(
            input === null || input === void 0 ? void 0 : input.userContext
          )
        });
      };
      RecipeWrapper2.addAxiosInterceptors = function(axiosInstance, userContext) {
        return recipe_1.default.addAxiosInterceptors(axiosInstance, (0, utils_1.getNormalisedUserContext)(userContext));
      };
      RecipeWrapper2.signOut = function(input) {
        return recipe_1.default.getInstanceOrThrow().signOut({
          userContext: (0, utils_1.getNormalisedUserContext)(
            input === null || input === void 0 ? void 0 : input.userContext
          )
        });
      };
      RecipeWrapper2.getClaimValue = function(input) {
        return recipe_1.default.getInstanceOrThrow().getClaimValue({
          claim: input.claim,
          userContext: (0, utils_1.getNormalisedUserContext)(
            input === null || input === void 0 ? void 0 : input.userContext
          )
        });
      };
      RecipeWrapper2.validateClaims = function(input) {
        return recipe_1.default.getInstanceOrThrow().validateClaims({
          overrideGlobalClaimValidators: input === null || input === void 0 ? void 0 : input.overrideGlobalClaimValidators,
          userContext: (0, utils_1.getNormalisedUserContext)(
            input === null || input === void 0 ? void 0 : input.userContext
          )
        });
      };
      RecipeWrapper2.getInvalidClaimsFromResponse = function(input) {
        return recipe_1.default.getInstanceOrThrow().getInvalidClaimsFromResponse({
          response: input.response,
          userContext: (0, utils_1.getNormalisedUserContext)(
            input === null || input === void 0 ? void 0 : input.userContext
          )
        });
      };
      return RecipeWrapper2;
    }();
    exports.default = RecipeWrapper;
    var init = RecipeWrapper.init;
    exports.init = init;
    var getUserId = RecipeWrapper.getUserId;
    exports.getUserId = getUserId;
    var getAccessTokenPayloadSecurely = RecipeWrapper.getAccessTokenPayloadSecurely;
    exports.getAccessTokenPayloadSecurely = getAccessTokenPayloadSecurely;
    var getAccessToken = RecipeWrapper.getAccessToken;
    exports.getAccessToken = getAccessToken;
    var attemptRefreshingSession = RecipeWrapper.attemptRefreshingSession;
    exports.attemptRefreshingSession = attemptRefreshingSession;
    var doesSessionExist = RecipeWrapper.doesSessionExist;
    exports.doesSessionExist = doesSessionExist;
    var addAxiosInterceptors = RecipeWrapper.addAxiosInterceptors;
    exports.addAxiosInterceptors = addAxiosInterceptors;
    var signOut = RecipeWrapper.signOut;
    exports.signOut = signOut;
    var validateClaims = RecipeWrapper.validateClaims;
    exports.validateClaims = validateClaims;
    var getClaimValue = RecipeWrapper.getClaimValue;
    exports.getClaimValue = getClaimValue;
    var getInvalidClaimsFromResponse = RecipeWrapper.getInvalidClaimsFromResponse;
    exports.getInvalidClaimsFromResponse = getInvalidClaimsFromResponse;
    var supertokens_website_1 = require_supertokens_website();
    Object.defineProperty(exports, "PrimitiveClaim", {
      enumerable: true,
      get: function() {
        return supertokens_website_1.PrimitiveClaim;
      }
    });
    Object.defineProperty(exports, "PrimitiveArrayClaim", {
      enumerable: true,
      get: function() {
        return supertokens_website_1.PrimitiveArrayClaim;
      }
    });
    Object.defineProperty(exports, "BooleanClaim", {
      enumerable: true,
      get: function() {
        return supertokens_website_1.BooleanClaim;
      }
    });
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/multitenancy/allowedDomainsClaim.js
var require_allowedDomainsClaim = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/multitenancy/allowedDomainsClaim.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AllowedDomainsClaim = exports.AllowedDomainsClaimClass = void 0;
    var windowHandler_1 = require_windowHandler2();
    var session_1 = require_session();
    var AllowedDomainsClaimClass = function(_super) {
      __extends(AllowedDomainsClaimClass2, _super);
      function AllowedDomainsClaimClass2() {
        var _this = _super.call(this, {
          id: "st-t-dmns",
          refresh: function() {
            return __awaiter(_this, void 0, void 0, function() {
              return __generator(this, function(_a) {
                return [2];
              });
            });
          },
          defaultMaxAgeInSeconds: Number.MAX_SAFE_INTEGER
        }) || this;
        _this.validators = __assign(__assign({}, _this.validators), {
          hasAccessToCurrentDomain: function() {
            return {
              id: _this.id,
              refresh: _this.refresh,
              shouldRefresh: function() {
                return false;
              },
              validate: function(payload, userContext) {
                return __awaiter(_this, void 0, void 0, function() {
                  var currentDomain, includesValidator;
                  return __generator(this, function(_a) {
                    currentDomain = windowHandler_1.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHostName();
                    includesValidator = this.validators.includes(
                      currentDomain,
                      Number.MAX_SAFE_INTEGER,
                      this.id
                    );
                    return [2, includesValidator.validate(payload, userContext)];
                  });
                });
              }
            };
          }
        });
        return _this;
      }
      return AllowedDomainsClaimClass2;
    }(session_1.PrimitiveArrayClaim);
    exports.AllowedDomainsClaimClass = AllowedDomainsClaimClass;
    exports.AllowedDomainsClaim = new AllowedDomainsClaimClass();
  }
});

// node_modules/supertokens-web-js/lib/build/recipe/multitenancy/index.js
var require_multitenancy = __commonJS({
  "node_modules/supertokens-web-js/lib/build/recipe/multitenancy/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AllowedDomainsClaim = exports.getTenantId = exports.getLoginMethods = exports.init = void 0;
    var utils_1 = require_utils2();
    var allowedDomainsClaim_1 = require_allowedDomainsClaim();
    Object.defineProperty(exports, "AllowedDomainsClaim", {
      enumerable: true,
      get: function() {
        return allowedDomainsClaim_1.AllowedDomainsClaim;
      }
    });
    var recipe_1 = require_recipe2();
    var RecipeWrapper = function() {
      function RecipeWrapper2() {
      }
      RecipeWrapper2.init = function(config) {
        return recipe_1.default.init(config);
      };
      RecipeWrapper2.getLoginMethods = function(input) {
        return recipe_1.default.getInstanceOrThrow().recipeImplementation.getLoginMethods(
          __assign(__assign({}, input), {
            userContext: (0, utils_1.getNormalisedUserContext)(
              input === null || input === void 0 ? void 0 : input.userContext
            )
          })
        );
      };
      RecipeWrapper2.getTenantId = function(input) {
        return recipe_1.default.getInstanceOrThrow().recipeImplementation.getTenantId(
          __assign(__assign({}, input), {
            userContext: (0, utils_1.getNormalisedUserContext)(
              input === null || input === void 0 ? void 0 : input.userContext
            )
          })
        );
      };
      RecipeWrapper2.AllowedDomainsClaim = allowedDomainsClaim_1.AllowedDomainsClaim;
      return RecipeWrapper2;
    }();
    exports.default = RecipeWrapper;
    var init = RecipeWrapper.init;
    exports.init = init;
    var getLoginMethods = RecipeWrapper.getLoginMethods;
    exports.getLoginMethods = getLoginMethods;
    var getTenantId = RecipeWrapper.getTenantId;
    exports.getTenantId = getTenantId;
  }
});

// node_modules/supertokens-web-js/recipe/multitenancy/index.js
var require_multitenancy2 = __commonJS({
  "node_modules/supertokens-web-js/recipe/multitenancy/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    __export(require_multitenancy());
  }
});

// node_modules/supertokens-web-js/utils/index.js
var require_utils6 = __commonJS({
  "node_modules/supertokens-web-js/utils/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    var d = require_utils2();
    if (d.default !== void 0) {
      __export(d);
    } else {
      __export({
        default: d,
        ...d
      });
    }
  }
});

// node_modules/supertokens-web-js/utils/normalisedURLDomain.js
var require_normalisedURLDomain3 = __commonJS({
  "node_modules/supertokens-web-js/utils/normalisedURLDomain.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    var d = require_normalisedURLDomain();
    if (d.default !== void 0) {
      __export(d);
    } else {
      __export({
        default: d,
        ...d
      });
    }
  }
});

// node_modules/supertokens-web-js/utils/normalisedURLPath.js
var require_normalisedURLPath3 = __commonJS({
  "node_modules/supertokens-web-js/utils/normalisedURLPath.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    var d = require_normalisedURLPath();
    if (d.default !== void 0) {
      __export(d);
    } else {
      __export({
        default: d,
        ...d
      });
    }
  }
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type, key, ref, self, source, owner, props) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            ref,
            props,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type, config, maybeKey, source, self) {
          {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self);
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
          {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type, props, key, source, self);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray(children)) {
                    for (var i = 0; i < children.length; i++) {
                      validateChildKeys(children[i], type);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type);
                }
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, true);
          }
        }
        function jsxWithValidationDynamic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, false);
          }
        }
        var jsx = jsxWithValidationDynamic;
        var jsxs = jsxWithValidationStatic;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsx;
        exports.jsxs = jsxs;
      })();
    }
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/supertokens-auth-react/lib/build/genericComponentOverrideContext.js
var require_genericComponentOverrideContext = __commonJS({
  "node_modules/supertokens-auth-react/lib/build/genericComponentOverrideContext.js"(exports) {
    "use strict";
    var SuperTokensWebJS = require_supertokens_web_js();
    var cookieHandler = require_cookieHandler4();
    var postSuperTokensInitCallbacks = require_postSuperTokensInitCallbacks2();
    var windowHandler = require_windowHandler4();
    var MultitenancyWebJS = require_multitenancy2();
    var utils = require_utils6();
    var React = require_react();
    var NormalisedURLDomain = require_normalisedURLDomain3();
    var NormalisedURLPath = require_normalisedURLPath3();
    var jsxRuntime = require_jsx_runtime();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var SuperTokensWebJS__default = _interopDefault(SuperTokensWebJS);
    var MultitenancyWebJS__default = _interopDefault(MultitenancyWebJS);
    var React__default = _interopDefault(React);
    var NormalisedURLDomain__default = _interopDefault(NormalisedURLDomain);
    var NormalisedURLPath__default = _interopDefault(NormalisedURLPath);
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    exports.__assign = function() {
      exports.__assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return exports.__assign.apply(this, arguments);
    };
    function __rest(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    }
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    }
    function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    }
    var RECIPE_ID_QUERY_PARAM = "rid";
    var DEFAULT_API_BASE_PATH = "/auth";
    var DEFAULT_WEBSITE_BASE_PATH = "/auth";
    var ST_ROOT_ID = "supertokens-root";
    var SSR_ERROR = "\nIf you are trying to use this method doing server-side-rendering, please make sure you move this method inside a componentDidMount method or useEffect hook.";
    function getRecipeIdFromSearch(search) {
      var urlParams = new URLSearchParams(search);
      return urlParams.get(RECIPE_ID_QUERY_PARAM);
    }
    function clearQueryParams(paramNames) {
      var newURL = new URL(windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHref());
      for (var _i = 0, paramNames_1 = paramNames; _i < paramNames_1.length; _i++) {
        var param = paramNames_1[_i];
        newURL.searchParams.delete(param);
      }
      windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.history.replaceState(
        windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.history.getState(),
        "",
        windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHref()
      );
    }
    function clearErrorQueryParam() {
      clearQueryParams(["error", "message"]);
    }
    function getQueryParams(param) {
      var urlParams = new URLSearchParams(
        windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getSearch()
      );
      return urlParams.get(param);
    }
    function getURLHash() {
      return windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHash().substr(1);
    }
    function getRedirectToPathFromURL() {
      var param = getQueryParams("redirectToPath");
      if (param === null) {
        return void 0;
      } else {
        try {
          var normalisedURLPath = new NormalisedURLPath__default.default(param).getAsStringDangerous();
          var pathQueryParams = param.split("?")[1] !== void 0 ? "?".concat(param.split("?")[1]) : "";
          return normalisedURLPath + pathQueryParams;
        } catch (_a) {
          return void 0;
        }
      }
    }
    function isTest() {
      try {
        return process.env.TEST_MODE === "testing";
      } catch (err) {
        return false;
      }
    }
    function normaliseInputAppInfoOrThrowError(appInfo) {
      if (appInfo === void 0) {
        throw new Error("Please provide the appInfo object when calling supertokens.init");
      }
      if (appInfo.apiDomain === void 0) {
        throw new Error("Please provide your apiDomain inside the appInfo object when calling supertokens.init");
      }
      if (appInfo.appName === void 0) {
        throw new Error("Please provide your appName inside the appInfo object when calling supertokens.init");
      }
      if (appInfo.websiteDomain === void 0) {
        throw new Error("Please provide your websiteDomain inside the appInfo object when calling supertokens.init");
      }
      var apiGatewayPath = new NormalisedURLPath__default.default("");
      if (appInfo.apiGatewayPath !== void 0) {
        apiGatewayPath = new NormalisedURLPath__default.default(appInfo.apiGatewayPath);
      }
      return {
        appName: appInfo.appName,
        apiDomain: new NormalisedURLDomain__default.default(appInfo.apiDomain),
        websiteDomain: new NormalisedURLDomain__default.default(appInfo.websiteDomain),
        apiBasePath: apiGatewayPath.appendPath(
          getNormalisedURLPathOrDefault(DEFAULT_API_BASE_PATH, appInfo.apiBasePath)
        ),
        websiteBasePath: getNormalisedURLPathOrDefault(DEFAULT_WEBSITE_BASE_PATH, appInfo.websiteBasePath)
      };
    }
    function getNormalisedURLPathOrDefault(defaultPath, path) {
      if (path !== void 0) {
        return new NormalisedURLPath__default.default(path);
      } else {
        return new NormalisedURLPath__default.default(defaultPath);
      }
    }
    function validateForm(inputs, configFormFields) {
      return __awaiter(this, void 0, void 0, function() {
        var validationErrors, _loop_1, i;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              validationErrors = [];
              if (configFormFields.length !== inputs.length) {
                throw Error("Are you sending too many / too few formFields?");
              }
              _loop_1 = function(i2) {
                var field, input, value, error;
                return __generator(this, function(_b) {
                  switch (_b.label) {
                    case 0:
                      field = configFormFields[i2];
                      input = inputs.find(function(i3) {
                        return i3.id === field.id;
                      });
                      value = input.value;
                      if (input.id === "email") {
                        value = value.trim();
                      }
                      return [4, field.validate(value)];
                    case 1:
                      error = _b.sent();
                      if (error !== void 0) {
                        validationErrors.push({
                          error,
                          id: field.id
                        });
                      }
                      return [2];
                  }
                });
              };
              i = 0;
              _a.label = 1;
            case 1:
              if (!(i < configFormFields.length))
                return [3, 4];
              return [5, _loop_1(i)];
            case 2:
              _a.sent();
              _a.label = 3;
            case 3:
              i++;
              return [3, 1];
            case 4:
              return [2, validationErrors];
          }
        });
      });
    }
    function getCurrentNormalisedUrlPath() {
      return new NormalisedURLPath__default.default(
        windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getPathName()
      );
    }
    function appendQueryParamsToURL(stringUrl, queryParams) {
      if (queryParams === void 0) {
        return stringUrl;
      }
      try {
        var url_1 = new URL(stringUrl);
        Object.entries(queryParams).forEach(function(_a) {
          var key = _a[0], value = _a[1];
          url_1.searchParams.set(key, value);
        });
        return url_1.href;
      } catch (e) {
        var fakeDomain = stringUrl.startsWith("/") ? "http:localhost" : "http://localhost/";
        var url_2 = new URL("".concat(fakeDomain).concat(stringUrl));
        Object.entries(queryParams).forEach(function(_a) {
          var key = _a[0], value = _a[1];
          url_2.searchParams.set(key, value);
        });
        return "".concat(url_2.pathname).concat(url_2.search);
      }
    }
    function appendTrailingSlashToURL(stringUrl) {
      return stringUrl.endsWith("/") ? stringUrl : stringUrl + "/";
    }
    function matchRecipeIdUsingQueryParams(recipeId) {
      return function() {
        var recipeIdFromSearch = getRecipeIdFromSearch(
          windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getSearch()
        );
        return recipeIdFromSearch === recipeId;
      };
    }
    function redirectWithFullPageReload(to) {
      if (to.trim() === "") {
        to = "/";
      }
      windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.setHref(to);
    }
    function redirectWithHistory(to, history) {
      if (to.trim() === "") {
        to = "/";
      }
      if (history.push !== void 0) {
        history.push(to);
      } else {
        history(to);
      }
    }
    function getOriginOfPage() {
      return new NormalisedURLDomain__default.default(
        windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getOrigin()
      );
    }
    function getLocalStorage(key) {
      return __awaiter(this, void 0, void 0, function() {
        var res;
        return __generator(this, function(_a) {
          res = windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.localStorage.getItem(key);
          if (res === null || res === void 0) {
            return [2, null];
          }
          return [2, res];
        });
      });
    }
    function setLocalStorage(key, value) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [
                4,
                windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.localStorage.setItem(
                  key,
                  value
                )
              ];
            case 1:
              _a.sent();
              return [2];
          }
        });
      });
    }
    function removeFromLocalStorage(key) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [
                4,
                windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.localStorage.removeItem(
                  key
                )
              ];
            case 1:
              _a.sent();
              return [2];
          }
        });
      });
    }
    function mergeObjects(obj1, obj2) {
      var res = exports.__assign({}, obj1);
      for (var key in obj2) {
        if (typeof res[key] === "object" && typeof obj2[key] === "object") {
          res[key] = mergeObjects(res[key], obj2[key]);
        } else {
          res[key] = obj2[key];
        }
      }
      return res;
    }
    function normaliseCookieScopeOrThrowError(cookieScope) {
      function helper(cookieScope2) {
        cookieScope2 = cookieScope2.trim().toLowerCase();
        if (cookieScope2.startsWith(".")) {
          cookieScope2 = cookieScope2.substr(1);
        }
        if (!cookieScope2.startsWith("http://") && !cookieScope2.startsWith("https://")) {
          cookieScope2 = "http://" + cookieScope2;
        }
        try {
          var urlObj = new URL(cookieScope2);
          cookieScope2 = urlObj.hostname;
          if (cookieScope2.startsWith(".")) {
            cookieScope2 = cookieScope2.substr(1);
          }
          return cookieScope2;
        } catch (err) {
          throw new Error("Please provide a valid cookie scope");
        }
      }
      function isAnIpAddress(ipaddress) {
        return /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(
          ipaddress
        );
      }
      var noDotNormalised = helper(cookieScope);
      if (noDotNormalised === "localhost" || isAnIpAddress(noDotNormalised)) {
        return noDotNormalised;
      }
      if (cookieScope.startsWith(".")) {
        return "." + noDotNormalised;
      }
      return noDotNormalised;
    }
    function getDefaultCookieScope() {
      try {
        return normaliseCookieScopeOrThrowError(
          windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHostName()
        );
      } catch (_a) {
        return void 0;
      }
    }
    function getCookieValue(name) {
      return __awaiter(this, void 0, void 0, function() {
        var value, _a, parts, last, temp;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _a = "; ";
              return [
                4,
                cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.getCookie()
              ];
            case 1:
              value = _a + _b.sent();
              parts = value.split("; " + name + "=");
              if (parts.length >= 2) {
                last = parts.pop();
                if (last !== void 0) {
                  temp = last.split(";").shift();
                  if (temp === void 0) {
                    return [2, null];
                  }
                  return [2, temp];
                }
              }
              return [2, null];
          }
        });
      });
    }
    function setFrontendCookie(name, value, scope) {
      return __awaiter(this, void 0, void 0, function() {
        var expires, cookieVal;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              expires = "Thu, 01 Jan 1970 00:00:01 GMT";
              cookieVal = "";
              if (value !== void 0) {
                cookieVal = value;
                expires = void 0;
              }
              if (!(scope === "localhost" || scope === windowHandler.WindowHandlerReference.getReferenceOrThrow().windowHandler.location.getHostName() || scope === void 0))
                return [3, 5];
              if (!(expires !== void 0))
                return [3, 2];
              return [
                4,
                cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.setCookie(
                  "".concat(name, "=").concat(cookieVal, ";expires=").concat(expires, ";path=/;samesite=lax")
                )
              ];
            case 1:
              _a.sent();
              return [3, 4];
            case 2:
              return [
                4,
                cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.setCookie(
                  "".concat(name, "=").concat(cookieVal, ";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=lax")
                )
              ];
            case 3:
              _a.sent();
              _a.label = 4;
            case 4:
              return [3, 9];
            case 5:
              if (!(expires !== void 0))
                return [3, 7];
              return [
                4,
                cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.setCookie(
                  "".concat(name, "=").concat(cookieVal, ";expires=").concat(expires, ";domain=").concat(scope, ";path=/;samesite=lax")
                )
              ];
            case 6:
              _a.sent();
              return [3, 9];
            case 7:
              return [
                4,
                cookieHandler.CookieHandlerReference.getReferenceOrThrow().cookieHandler.setCookie(
                  "".concat(name, "=").concat(cookieVal, ";domain=").concat(scope, ";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=lax")
                )
              ];
            case 8:
              _a.sent();
              _a.label = 9;
            case 9:
              return [2];
          }
        });
      });
    }
    function getNormalisedUserContext(userContext) {
      return userContext === void 0 ? {} : userContext;
    }
    var useOnMountAPICall = function(fetch2, handleResponse, handleError, startLoading) {
      if (startLoading === void 0) {
        startLoading = true;
      }
      var consumeReq = React.useRef();
      var _a = React.useState(void 0), error = _a[0], setError = _a[1];
      React.useEffect(
        function() {
          var effect = function(signal) {
            return __awaiter(void 0, void 0, void 0, function() {
              var resp, err_1;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    _a2.trys.push([0, 2, , 3]);
                    if (consumeReq.current === void 0) {
                      consumeReq.current = fetch2();
                    }
                    return [4, consumeReq.current];
                  case 1:
                    resp = _a2.sent();
                    if (!signal.aborted) {
                      void handleResponse(resp);
                    }
                    return [3, 3];
                  case 2:
                    err_1 = _a2.sent();
                    if (!signal.aborted) {
                      if (handleError !== void 0) {
                        handleError(err_1, resp);
                      } else {
                        setError(err_1);
                      }
                    }
                    return [3, 3];
                  case 3:
                    return [2];
                }
              });
            });
          };
          if (startLoading) {
            var ctrl_1 = new AbortController();
            void effect(ctrl_1.signal);
            return function() {
              ctrl_1.abort();
            };
          }
          return;
        },
        [setError, consumeReq, fetch2, handleResponse, handleError, startLoading]
      );
      if (error) {
        throw error;
      }
    };
    var BaseRecipeModule = function() {
      function BaseRecipeModule2(config) {
        this.config = config;
      }
      return BaseRecipeModule2;
    }();
    function normaliseRecipeModuleConfig(config) {
      var _this = this;
      if (config === void 0) {
        config = {};
      }
      var onHandleEvent = config.onHandleEvent, getRedirectionURL = config.getRedirectionURL, preAPIHook = config.preAPIHook, postAPIHook = config.postAPIHook;
      if (onHandleEvent === void 0) {
        onHandleEvent = function(_) {
        };
      }
      if (getRedirectionURL === void 0) {
        getRedirectionURL = function(_) {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, void 0];
            });
          });
        };
      }
      if (preAPIHook === void 0) {
        preAPIHook = function(context) {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2, context];
            });
          });
        };
      }
      if (postAPIHook === void 0) {
        postAPIHook = function() {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              return [2];
            });
          });
        };
      }
      var useShadowDom = config.useShadowDom === void 0 ? true : config.useShadowDom;
      useShadowDom = getShouldUseShadowDomBasedOnBrowser(useShadowDom);
      var rootStyle = config.style === void 0 ? "" : config.style;
      return exports.__assign(exports.__assign({}, config), {
        getRedirectionURL,
        onHandleEvent,
        preAPIHook,
        postAPIHook,
        useShadowDom,
        rootStyle
      });
    }
    function getShouldUseShadowDomBasedOnBrowser(useShadowDom) {
      return useShadowDom !== void 0 ? useShadowDom : true;
    }
    function normaliseMultitenancyConfig(config) {
      return exports.__assign(exports.__assign({}, normaliseRecipeModuleConfig(config)), {
        override: exports.__assign(
          {
            functions: function(originalImplementation) {
              return originalImplementation;
            }
          },
          config === null || config === void 0 ? void 0 : config.override
        )
      });
    }
    function hasIntersectingRecipes(tenantMethods, recipeList) {
      var _loop_1 = function(key2) {
        var hasIntersection = recipeList.some(function(recipe) {
          if (tenantMethods[key2].enabled) {
            return recipe.recipeID === key2 || recipe.recipeID.includes(key2);
          }
          return false;
        });
        if (hasIntersection === true) {
          return { value: true };
        }
      };
      for (var key in tenantMethods) {
        var state_1 = _loop_1(key);
        if (typeof state_1 === "object")
          return state_1.value;
      }
      return false;
    }
    var Multitenancy = function(_super) {
      __extends(Multitenancy2, _super);
      function Multitenancy2(config, webJSRecipe) {
        if (webJSRecipe === void 0) {
          webJSRecipe = MultitenancyWebJS__default.default;
        }
        var _this = _super.call(this, config) || this;
        _this.webJSRecipe = webJSRecipe;
        _this.recipeID = Multitenancy2.RECIPE_ID;
        _this.dynamicLoginMethodsCache = {};
        return _this;
      }
      Multitenancy2.prototype.getCurrentDynamicLoginMethods = function(input) {
        var _a;
        return __awaiter(this, void 0, void 0, function() {
          var userContext, tenantId, tenantMethods;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (SuperTokens.usesDynamicLoginMethods === false) {
                  return [2, void 0];
                }
                userContext = utils.getNormalisedUserContext(input.userContext);
                return [4, Multitenancy2.getInstanceOrThrow().webJSRecipe.getTenantId()];
              case 1:
                tenantId = (_a = _b.sent()) !== null && _a !== void 0 ? _a : "public";
                if (this.dynamicLoginMethodsCache[tenantId] === void 0) {
                  this.dynamicLoginMethodsCache[tenantId] = Multitenancy2.getDynamicLoginMethods({
                    tenantId,
                    userContext
                  });
                }
                return [4, this.dynamicLoginMethodsCache[tenantId]];
              case 2:
                tenantMethods = _b.sent();
                if (!hasIntersectingRecipes(tenantMethods, SuperTokens.getInstanceOrThrow().recipeList)) {
                  throw new Error(
                    "Initialized recipes have no overlap with core recipes or could not load login methods"
                  );
                }
                return [2, tenantMethods];
            }
          });
        });
      };
      Multitenancy2.getDynamicLoginMethods = function(input) {
        return __awaiter(this, void 0, void 0, function() {
          var _a, emailPassword, passwordless, thirdParty;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, MultitenancyWebJS__default.default.getLoginMethods(input)];
              case 1:
                _a = _b.sent(), emailPassword = _a.emailPassword, passwordless = _a.passwordless, thirdParty = _a.thirdParty;
                return [
                  2,
                  {
                    passwordless,
                    emailpassword: emailPassword,
                    thirdparty: thirdParty
                  }
                ];
            }
          });
        });
      };
      Multitenancy2.init = function(config) {
        var normalisedConfig = normaliseMultitenancyConfig(config);
        return {
          recipeID: Multitenancy2.RECIPE_ID,
          authReact: function(appInfo) {
            Multitenancy2.instance = new Multitenancy2(
              exports.__assign(exports.__assign({}, normalisedConfig), {
                appInfo,
                recipeId: Multitenancy2.RECIPE_ID
              })
            );
            return Multitenancy2.instance;
          },
          webJS: MultitenancyWebJS__default.default.init(exports.__assign({}, normalisedConfig))
        };
      };
      Multitenancy2.getInstanceOrThrow = function() {
        if (Multitenancy2.instance === void 0) {
          var error = "No instance of Multitenancy found. Make sure to call the Multitenancy.init method.See https://supertokens.io/docs/multitenancy/quick-setup/frontend";
          if (typeof window === "undefined") {
            error = error + SSR_ERROR;
          }
          throw Error(error);
        }
        return Multitenancy2.instance;
      };
      Multitenancy2.reset = function() {
        if (!isTest()) {
          return;
        }
        Multitenancy2.instance = void 0;
        return;
      };
      Multitenancy2.RECIPE_ID = "multitenancy";
      return Multitenancy2;
    }(BaseRecipeModule);
    var TranslationController = function() {
      function TranslationController2() {
        this.handlers = /* @__PURE__ */ new Map();
      }
      TranslationController2.prototype.emit = function(event, detail) {
        var handlerList = this.handlers.get(event) || [];
        for (var _i = 0, handlerList_1 = handlerList; _i < handlerList_1.length; _i++) {
          var h = handlerList_1[_i];
          h(event, detail);
        }
      };
      TranslationController2.prototype.on = function(event, handler) {
        var handlerList = this.handlers.get(event) || [];
        this.handlers.set(event, handlerList.concat(handler));
      };
      TranslationController2.prototype.off = function(event, handler) {
        var handlerList = this.handlers.get(event) || [];
        this.handlers.set(
          event,
          handlerList.filter(function(h) {
            return h !== handler;
          })
        );
      };
      return TranslationController2;
    }();
    var CURRENT_LANGUAGE_COOKIE_NAME = "sCurrLanguage";
    function saveCurrentLanguage(language, cookieDomain) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 2, , 3]);
              return [4, setFrontendCookie(CURRENT_LANGUAGE_COOKIE_NAME, language, cookieDomain)];
            case 1:
              _b.sent();
              return [3, 3];
            case 2:
              _b.sent();
              return [3, 3];
            case 3:
              return [2];
          }
        });
      });
    }
    function getCurrentLanguageFromCookie() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 2, , 3]);
              return [4, getCookieValue(CURRENT_LANGUAGE_COOKIE_NAME)];
            case 1:
              return [2, _b.sent()];
            case 2:
              _b.sent();
              return [2, null];
            case 3:
              return [2];
          }
        });
      });
    }
    var SuperTokens = function() {
      function SuperTokens2(config) {
        var _this = this;
        this.recipeList = [];
        this.changeLanguage = function(lang) {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [
                    4,
                    saveCurrentLanguage(lang, this.languageTranslations.currentLanguageCookieScope)
                  ];
                case 1:
                  _a.sent();
                  this.languageTranslations.translationEventSource.emit("LanguageChange", lang);
                  return [2];
              }
            });
          });
        };
        this.redirectToAuth = function(options) {
          return __awaiter(_this, void 0, void 0, function() {
            var queryParams, redirectUrl;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  queryParams = options.queryParams === void 0 ? {} : options.queryParams;
                  if (options.show !== void 0) {
                    queryParams.show = options.show;
                  }
                  if (options.redirectBack === true) {
                    queryParams.redirectToPath = getCurrentNormalisedUrlPath().getAsStringDangerous();
                  }
                  return [
                    4,
                    this.getRedirectUrl({
                      action: "TO_AUTH",
                      showSignIn: options.show === "signin"
                    })
                  ];
                case 1:
                  redirectUrl = _a.sent();
                  redirectUrl = appendQueryParamsToURL(redirectUrl, queryParams);
                  return [2, this.redirectToUrl(redirectUrl, options.history)];
              }
            });
          });
        };
        this.redirectToUrl = function(redirectUrl, history) {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              doRedirection(this.appInfo, redirectUrl, history);
              return [2];
            });
          });
        };
        this.appInfo = normaliseInputAppInfoOrThrowError(config.appInfo);
        if (config.recipeList === void 0 || config.recipeList.length === 0) {
          throw new Error(
            "Please provide at least one recipe to the supertokens.init function call. See https://supertokens.io/docs/emailpassword/quick-setup/frontend"
          );
        }
        var translationConfig = config.languageTranslations === void 0 ? {} : config.languageTranslations;
        this.languageTranslations = {
          defaultLanguage: translationConfig.defaultLanguage === void 0 ? "en" : translationConfig.defaultLanguage,
          currentLanguageCookieScope: translationConfig.currentLanguageCookieScope !== void 0 ? normaliseCookieScopeOrThrowError(translationConfig.currentLanguageCookieScope) : getDefaultCookieScope(),
          userTranslationStore: translationConfig.translations !== void 0 ? translationConfig.translations : {},
          translationEventSource: new TranslationController(),
          userTranslationFunc: translationConfig.translationFunc
        };
        var enableDebugLogs = false;
        if (config.enableDebugLogs !== void 0) {
          enableDebugLogs = config.enableDebugLogs;
        }
        this.userGetRedirectionURL = config.getRedirectionURL;
        this.recipeList = config.recipeList.map(function(_a) {
          var authReact = _a.authReact;
          return authReact(_this.appInfo, enableDebugLogs);
        });
      }
      SuperTokens2.init = function(config) {
        var _a;
        cookieHandler.CookieHandlerReference.init(config.cookieHandler);
        windowHandler.WindowHandlerReference.init(config.windowHandler);
        if (SuperTokens2.instance !== void 0) {
          console.warn("SuperTokens was already initialized");
          return;
        }
        SuperTokens2.usesDynamicLoginMethods = (_a = config.usesDynamicLoginMethods) !== null && _a !== void 0 ? _a : false;
        var recipes = config.recipeList.find(function(recipe) {
          return recipe.recipeID === Multitenancy.RECIPE_ID;
        }) !== void 0 ? config.recipeList : config.recipeList.concat(Multitenancy.init({}));
        SuperTokensWebJS__default.default.init(
          exports.__assign(exports.__assign({}, config), {
            recipeList: recipes.map(function(_a2) {
              var webJS = _a2.webJS;
              return webJS;
            })
          })
        );
        SuperTokens2.instance = new SuperTokens2(exports.__assign(exports.__assign({}, config), { recipeList: recipes }));
        postSuperTokensInitCallbacks.PostSuperTokensInitCallbacks.runPostInitCallbacks();
      };
      SuperTokens2.getInstanceOrThrow = function() {
        if (SuperTokens2.instance === void 0) {
          var error = "SuperTokens must be initialized before calling this method.";
          if (typeof window === "undefined") {
            error = error + SSR_ERROR;
          }
          throw new Error(error);
        }
        return SuperTokens2.instance;
      };
      SuperTokens2.prototype.getRecipeOrThrow = function(recipeId) {
        var recipe = this.recipeList.find(function(recipe2) {
          return recipe2.config.recipeId === recipeId;
        });
        if (recipe === void 0) {
          throw new Error("Missing recipe: ".concat(recipeId));
        }
        return recipe;
      };
      SuperTokens2.prototype.loadTranslation = function(store) {
        this.languageTranslations.translationEventSource.emit("TranslationLoaded", store);
      };
      SuperTokens2.prototype.getRedirectUrl = function(context) {
        return __awaiter(this, void 0, void 0, function() {
          var userRes, redirectUrl;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!this.userGetRedirectionURL)
                  return [3, 2];
                return [4, this.userGetRedirectionURL(context)];
              case 1:
                userRes = _a.sent();
                if (userRes !== void 0) {
                  return [2, userRes];
                }
                _a.label = 2;
              case 2:
                if (context.action === "TO_AUTH") {
                  redirectUrl = this.appInfo.websiteBasePath.getAsStringDangerous();
                  return [2, appendTrailingSlashToURL(redirectUrl)];
                }
                throw new Error("Should never come here: unexpected redirection context");
            }
          });
        });
      };
      SuperTokens2.reset = function() {
        if (!isTest()) {
          return;
        }
        SuperTokens2.instance = void 0;
        return;
      };
      SuperTokens2.usesDynamicLoginMethods = false;
      return SuperTokens2;
    }();
    function doRedirection(appInfo, redirectUrl, history) {
      try {
        new URL(redirectUrl);
      } catch (e) {
        var origin_1 = getOriginOfPage().getAsStringDangerous();
        if (origin_1 !== appInfo.websiteDomain.getAsStringDangerous()) {
          redirectUrl = "".concat(appInfo.websiteDomain.getAsStringDangerous()).concat(redirectUrl);
          redirectWithFullPageReload(redirectUrl);
          return;
        }
        if (history !== void 0) {
          redirectWithHistory(redirectUrl, history);
          return;
        }
      }
      redirectWithFullPageReload(redirectUrl);
    }
    var createGenericComponentsOverrideContext = function(v) {
      if (v === void 0) {
        v = {};
      }
      var genericContext = React__default.default.createContext(v);
      var useComponentsOverrideContext = function() {
        return React__default.default.useContext(genericContext);
      };
      var Provider = function(_a) {
        var children = _a.children, components = _a.components;
        return jsxRuntime.jsx(genericContext.Provider, exports.__assign({ value: components }, { children }));
      };
      return [useComponentsOverrideContext, Provider, genericContext.Consumer];
    };
    exports.BaseRecipeModule = BaseRecipeModule;
    exports.Multitenancy = Multitenancy;
    exports.SSR_ERROR = SSR_ERROR;
    exports.ST_ROOT_ID = ST_ROOT_ID;
    exports.SuperTokens = SuperTokens;
    exports.__awaiter = __awaiter;
    exports.__extends = __extends;
    exports.__generator = __generator;
    exports.__rest = __rest;
    exports.__spreadArray = __spreadArray;
    exports.appendQueryParamsToURL = appendQueryParamsToURL;
    exports.clearErrorQueryParam = clearErrorQueryParam;
    exports.clearQueryParams = clearQueryParams;
    exports.createGenericComponentsOverrideContext = createGenericComponentsOverrideContext;
    exports.getCurrentLanguageFromCookie = getCurrentLanguageFromCookie;
    exports.getCurrentNormalisedUrlPath = getCurrentNormalisedUrlPath;
    exports.getLocalStorage = getLocalStorage;
    exports.getNormalisedUserContext = getNormalisedUserContext;
    exports.getQueryParams = getQueryParams;
    exports.getRedirectToPathFromURL = getRedirectToPathFromURL;
    exports.getURLHash = getURLHash;
    exports.isTest = isTest;
    exports.matchRecipeIdUsingQueryParams = matchRecipeIdUsingQueryParams;
    exports.mergeObjects = mergeObjects;
    exports.normaliseRecipeModuleConfig = normaliseRecipeModuleConfig;
    exports.redirectWithFullPageReload = redirectWithFullPageReload;
    exports.removeFromLocalStorage = removeFromLocalStorage;
    exports.setLocalStorage = setLocalStorage;
    exports.useOnMountAPICall = useOnMountAPICall;
    exports.validateForm = validateForm;
  }
});

// node_modules/supertokens-auth-react/lib/build/translationContext.js
var require_translationContext = __commonJS({
  "node_modules/supertokens-auth-react/lib/build/translationContext.js"(exports) {
    "use strict";
    var genericComponentOverrideContext = require_genericComponentOverrideContext();
    var jsxRuntime = require_jsx_runtime();
    var React = require_react();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var React__default = _interopDefault(React);
    var errCB = function() {
      throw new Error("Cannot use translation func outside TranslationContext provider.");
    };
    var TranslationContext = React__default.default.createContext({
      translate: errCB
    });
    var useTranslation = function() {
      return React.useContext(TranslationContext).translate;
    };
    var TranslationContextProvider = function(_a) {
      var children = _a.children, defaultLanguage = _a.defaultLanguage, userTranslationFunc = _a.userTranslationFunc, defaultStore = _a.defaultStore, translationControlEventSource = _a.translationControlEventSource;
      var _b = React.useState(defaultStore), translationStore = _b[0], setTranslationStore = _b[1];
      var _c = React.useState(void 0), currentLanguage = _c[0], setCurrentLanguage = _c[1];
      React.useEffect(
        function() {
          function loadLanguageFromCookies() {
            return genericComponentOverrideContext.__awaiter(this, void 0, void 0, function() {
              var cookieLang, cookieLangTemp;
              return genericComponentOverrideContext.__generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    return [4, genericComponentOverrideContext.getCurrentLanguageFromCookie()];
                  case 1:
                    cookieLang = _a2.sent();
                    cookieLangTemp = cookieLang === null ? defaultLanguage : cookieLang;
                    setCurrentLanguage(function(current) {
                      return current !== void 0 ? current : cookieLangTemp;
                    });
                    return [2];
                }
              });
            });
          }
          void loadLanguageFromCookies();
        },
        [defaultLanguage, setCurrentLanguage]
      );
      React.useEffect(function() {
        var changeHandler = function(_eventName, detail) {
          setCurrentLanguage(detail);
        };
        var loadHandler = function(_eventName, detail) {
          setTranslationStore(function(os) {
            return genericComponentOverrideContext.mergeObjects(os, detail);
          });
        };
        translationControlEventSource.on("LanguageChange", changeHandler);
        translationControlEventSource.on("TranslationLoaded", loadHandler);
        return function() {
          translationControlEventSource.off("LanguageChange", changeHandler);
          translationControlEventSource.off("TranslationLoaded", loadHandler);
        };
      });
      var translateFunc = React.useCallback(
        function(key) {
          if (userTranslationFunc !== void 0) {
            return userTranslationFunc(key);
          }
          if (currentLanguage !== void 0) {
            var res = translationStore[currentLanguage] && translationStore[currentLanguage][key];
            var fallback = translationStore[defaultLanguage] && translationStore[defaultLanguage][key];
            if (res === void 0) {
              if (fallback !== void 0) {
                return fallback;
              }
              return key;
            }
            return res;
          }
          throw new Error("Should never come here");
        },
        [translationStore, currentLanguage, defaultLanguage, userTranslationFunc]
      );
      if (currentLanguage === void 0) {
        return null;
      }
      return jsxRuntime.jsx(
        TranslationContext.Provider,
        genericComponentOverrideContext.__assign({ value: { translate: translateFunc } }, { children })
      );
    };
    exports.TranslationContextProvider = TranslationContextProvider;
    exports.useTranslation = useTranslation;
  }
});

// node_modules/supertokens-web-js/recipe/session/index.js
var require_session2 = __commonJS({
  "node_modules/supertokens-web-js/recipe/session/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    exports.__esModule = true;
    __export(require_session());
  }
});

// node_modules/supertokens-auth-react/lib/build/recipeModule-shared.js
var require_recipeModule_shared = __commonJS({
  "node_modules/supertokens-auth-react/lib/build/recipeModule-shared.js"(exports) {
    "use strict";
    var genericComponentOverrideContext = require_genericComponentOverrideContext();
    var RecipeModule = function(_super) {
      genericComponentOverrideContext.__extends(RecipeModule2, _super);
      function RecipeModule2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.redirect = function(context, history, queryParams) {
          return genericComponentOverrideContext.__awaiter(_this, void 0, void 0, function() {
            var redirectUrl;
            return genericComponentOverrideContext.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getRedirectUrl(context)];
                case 1:
                  redirectUrl = _a.sent();
                  redirectUrl = genericComponentOverrideContext.appendQueryParamsToURL(
                    redirectUrl,
                    queryParams
                  );
                  return [
                    2,
                    genericComponentOverrideContext.SuperTokens.getInstanceOrThrow().redirectToUrl(
                      redirectUrl,
                      history
                    )
                  ];
              }
            });
          });
        };
        _this.getRedirectUrl = function(context) {
          return genericComponentOverrideContext.__awaiter(_this, void 0, void 0, function() {
            var redirectUrl;
            return genericComponentOverrideContext.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.config.getRedirectionURL(context)];
                case 1:
                  redirectUrl = _a.sent();
                  if (redirectUrl !== void 0) {
                    return [2, redirectUrl];
                  }
                  return [4, this.getDefaultRedirectionURL(context)];
                case 2:
                  return [2, _a.sent()];
              }
            });
          });
        };
        return _this;
      }
      RecipeModule2.prototype.getDefaultRedirectionURL = function(_) {
        return genericComponentOverrideContext.__awaiter(this, void 0, void 0, function() {
          return genericComponentOverrideContext.__generator(this, function(_a) {
            throw new Error("getDefaultRedirectionURL is not implemented.");
          });
        });
      };
      return RecipeModule2;
    }(genericComponentOverrideContext.BaseRecipeModule);
    exports.RecipeModule = RecipeModule;
  }
});

// node_modules/supertokens-auth-react/lib/build/session-shared2.js
var require_session_shared2 = __commonJS({
  "node_modules/supertokens-auth-react/lib/build/session-shared2.js"(exports) {
    "use strict";
    var genericComponentOverrideContext = require_genericComponentOverrideContext();
    var WebJSSessionRecipe = require_session2();
    var index = require_recipeModule_shared();
    var utils = require_utils6();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var WebJSSessionRecipe__default = _interopDefault(WebJSSessionRecipe);
    function normaliseSessionConfig(config) {
      var _a, _b;
      if (config === void 0) {
        config = {};
      }
      var accessDeniedScreenStyle = (_b = (_a = config.accessDeniedScreen) === null || _a === void 0 ? void 0 : _a.style) !== null && _b !== void 0 ? _b : "";
      var accessDeniedScreen = {
        style: accessDeniedScreenStyle
      };
      var override = genericComponentOverrideContext.__assign(
        {
          functions: function(originalImplementation) {
            return originalImplementation;
          }
        },
        config.override
      );
      return genericComponentOverrideContext.__assign(
        genericComponentOverrideContext.__assign(
          {},
          genericComponentOverrideContext.normaliseRecipeModuleConfig(config)
        ),
        { accessDeniedScreen, override }
      );
    }
    var getFailureRedirectionInfo = function(_a) {
      var invalidClaims = _a.invalidClaims, overrideGlobalClaimValidators = _a.overrideGlobalClaimValidators, userContext = _a.userContext;
      return genericComponentOverrideContext.__awaiter(void 0, void 0, void 0, function() {
        var globalValidators, failedClaim, _loop_1, _i, globalValidators_1, validator, state_1;
        return genericComponentOverrideContext.__generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              globalValidators = utils.getGlobalClaimValidators({
                overrideGlobalClaimValidators,
                userContext
              });
              failedClaim = void 0;
              _loop_1 = function(validator2) {
                var claim, failureCallback, redirectPath;
                return genericComponentOverrideContext.__generator(this, function(_c) {
                  switch (_c.label) {
                    case 0:
                      claim = invalidClaims.find(function(c) {
                        return c.validatorId === validator2.id;
                      });
                      if (!(claim !== void 0))
                        return [3, 2];
                      failureCallback = validator2.onFailureRedirection;
                      if (!failureCallback)
                        return [3, 2];
                      return [
                        4,
                        failureCallback({ reason: claim.reason, userContext })
                      ];
                    case 1:
                      redirectPath = _c.sent();
                      if (redirectPath !== void 0) {
                        return [
                          2,
                          {
                            value: {
                              redirectPath,
                              failedClaim: claim
                            }
                          }
                        ];
                      }
                      _c.label = 2;
                    case 2:
                      if (validator2.showAccessDeniedOnFailure !== false && failedClaim === void 0) {
                        failedClaim = claim;
                      }
                      return [2];
                  }
                });
              };
              _i = 0, globalValidators_1 = globalValidators;
              _b.label = 1;
            case 1:
              if (!(_i < globalValidators_1.length))
                return [3, 4];
              validator = globalValidators_1[_i];
              return [5, _loop_1(validator)];
            case 2:
              state_1 = _b.sent();
              if (typeof state_1 === "object")
                return [2, state_1.value];
              _b.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              return [
                2,
                {
                  redirectPath: void 0,
                  failedClaim
                }
              ];
          }
        });
      });
    };
    var Session = function(_super) {
      genericComponentOverrideContext.__extends(Session2, _super);
      function Session2(config, webJSRecipe) {
        if (webJSRecipe === void 0) {
          webJSRecipe = WebJSSessionRecipe__default.default;
        }
        var _this = _super.call(this, config) || this;
        _this.webJSRecipe = webJSRecipe;
        _this.recipeID = Session2.RECIPE_ID;
        _this.eventListeners = /* @__PURE__ */ new Set();
        _this.redirectionHandlersFromAuthRecipes = /* @__PURE__ */ new Map();
        _this.getUserId = function(input) {
          return _this.webJSRecipe.getUserId(input);
        };
        _this.getAccessToken = function(input) {
          return _this.webJSRecipe.getAccessToken(input);
        };
        _this.getClaimValue = function(input) {
          return _this.webJSRecipe.getClaimValue(input);
        };
        _this.getAccessTokenPayloadSecurely = function(input) {
          return genericComponentOverrideContext.__awaiter(_this, void 0, void 0, function() {
            return genericComponentOverrideContext.__generator(this, function(_a) {
              return [2, this.webJSRecipe.getAccessTokenPayloadSecurely(input)];
            });
          });
        };
        _this.doesSessionExist = function(input) {
          return _this.webJSRecipe.doesSessionExist(input);
        };
        _this.signOut = function(input) {
          return _this.webJSRecipe.signOut(input);
        };
        _this.attemptRefreshingSession = function() {
          return genericComponentOverrideContext.__awaiter(_this, void 0, void 0, function() {
            return genericComponentOverrideContext.__generator(this, function(_a) {
              return [2, this.webJSRecipe.attemptRefreshingSession()];
            });
          });
        };
        _this.validateClaims = function(input) {
          return _this.webJSRecipe.validateClaims(input);
        };
        _this.getInvalidClaimsFromResponse = function(input) {
          return _this.webJSRecipe.getInvalidClaimsFromResponse(input);
        };
        _this.addEventListener = function(listener) {
          _this.eventListeners.add(listener);
          return function() {
            return _this.eventListeners.delete(listener);
          };
        };
        _this.addAuthRecipeRedirectionHandler = function(rid, redirect) {
          _this.redirectionHandlersFromAuthRecipes.set(rid, redirect);
        };
        _this.validateGlobalClaimsAndHandleSuccessRedirection = function(redirectInfo, userContext, history) {
          return genericComponentOverrideContext.__awaiter(_this, void 0, void 0, function() {
            var invalidClaims, jsonContext, failureRedirectInfo, successContextStr, authRecipeRedirectHandler;
            return genericComponentOverrideContext.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.doesSessionExist({ userContext })];
                case 1:
                  if (!_a.sent()) {
                    return [
                      2,
                      genericComponentOverrideContext.SuperTokens.getInstanceOrThrow().redirectToAuth({
                        history,
                        redirectBack: false
                      })
                    ];
                  }
                  return [4, this.validateClaims({ userContext })];
                case 2:
                  invalidClaims = _a.sent();
                  if (!(invalidClaims.length > 0))
                    return [3, 6];
                  if (!(redirectInfo !== void 0))
                    return [3, 4];
                  jsonContext = JSON.stringify(redirectInfo);
                  return [
                    4,
                    genericComponentOverrideContext.setLocalStorage(
                      "supertokens-success-redirection-context",
                      jsonContext
                    )
                  ];
                case 3:
                  _a.sent();
                  _a.label = 4;
                case 4:
                  return [
                    4,
                    getFailureRedirectionInfo({
                      invalidClaims,
                      userContext
                    })
                  ];
                case 5:
                  failureRedirectInfo = _a.sent();
                  if (failureRedirectInfo.redirectPath !== void 0) {
                    return [
                      2,
                      genericComponentOverrideContext.SuperTokens.getInstanceOrThrow().redirectToUrl(
                        failureRedirectInfo.redirectPath,
                        history
                      )
                    ];
                  }
                  _a.label = 6;
                case 6:
                  if (!(redirectInfo === void 0))
                    return [3, 13];
                  return [
                    4,
                    genericComponentOverrideContext.getLocalStorage(
                      "supertokens-success-redirection-context"
                    )
                  ];
                case 7:
                  successContextStr = _a.sent();
                  if (!(successContextStr !== null))
                    return [3, 12];
                  _a.label = 8;
                case 8:
                  _a.trys.push([8, , 9, 11]);
                  redirectInfo = JSON.parse(successContextStr);
                  return [3, 11];
                case 9:
                  return [
                    4,
                    genericComponentOverrideContext.removeFromLocalStorage(
                      "supertokens-success-redirection-context"
                    )
                  ];
                case 10:
                  _a.sent();
                  return [7];
                case 11:
                  return [3, 13];
                case 12:
                  redirectInfo = {
                    rid: Session2.RECIPE_ID,
                    successRedirectContext: {
                      action: "SUCCESS",
                      isNewUser: false
                    }
                  };
                  _a.label = 13;
                case 13:
                  authRecipeRedirectHandler = this.redirectionHandlersFromAuthRecipes.get(redirectInfo.rid);
                  if (authRecipeRedirectHandler !== void 0) {
                    return [
                      2,
                      authRecipeRedirectHandler(redirectInfo.successRedirectContext, history)
                    ];
                  }
                  return [2, this.redirect(redirectInfo.successRedirectContext, history)];
              }
            });
          });
        };
        _this.getDefaultRedirectionURL = function() {
          return genericComponentOverrideContext.__awaiter(_this, void 0, void 0, function() {
            return genericComponentOverrideContext.__generator(this, function(_a) {
              return [2, "/"];
            });
          });
        };
        _this.notifyListeners = function(event) {
          return genericComponentOverrideContext.__awaiter(_this, void 0, void 0, function() {
            var sessionContext;
            return genericComponentOverrideContext.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.getSessionContext(event)];
                case 1:
                  sessionContext = _a.sent();
                  Array.from(this.eventListeners).forEach(function(listener) {
                    return listener(
                      genericComponentOverrideContext.__assign({ sessionContext }, event)
                    );
                  });
                  return [2];
              }
            });
          });
        };
        return _this;
      }
      Session2.prototype.getSessionContext = function(_a) {
        var action = _a.action, userContext = _a.userContext;
        return genericComponentOverrideContext.__awaiter(this, void 0, void 0, function() {
          var _b, userId, accessTokenPayload;
          return genericComponentOverrideContext.__generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                if (!(action === "SESSION_CREATED" || action === "REFRESH_SESSION" || action === "API_INVALID_CLAIM" || action === "ACCESS_TOKEN_PAYLOAD_UPDATED"))
                  return [3, 2];
                return [
                  4,
                  Promise.all([
                    this.getUserId({
                      userContext
                    }),
                    this.getAccessTokenPayloadSecurely({
                      userContext
                    })
                  ])
                ];
              case 1:
                _b = _c.sent(), userId = _b[0], accessTokenPayload = _b[1];
                return [
                  2,
                  {
                    doesSessionExist: true,
                    accessTokenPayload,
                    userId
                  }
                ];
              case 2:
                if (action === "SIGN_OUT" || action === "UNAUTHORISED") {
                  return [
                    2,
                    {
                      doesSessionExist: false,
                      accessTokenPayload: {},
                      userId: ""
                    }
                  ];
                }
                throw new Error("Unhandled recipe event: ".concat(action));
            }
          });
        });
      };
      Session2.addAxiosInterceptors = function(axiosInstance, userContext) {
        return WebJSSessionRecipe__default.default.addAxiosInterceptors(axiosInstance, userContext);
      };
      Session2.init = function(config) {
        var _this = this;
        var normalisedConfig = normaliseSessionConfig(config);
        return {
          recipeID: Session2.RECIPE_ID,
          authReact: function(appInfo) {
            Session2.instance = new Session2(
              genericComponentOverrideContext.__assign(
                genericComponentOverrideContext.__assign({}, normalisedConfig),
                { appInfo, recipeId: Session2.RECIPE_ID }
              )
            );
            return Session2.instance;
          },
          webJS: WebJSSessionRecipe__default.default.init(
            genericComponentOverrideContext.__assign(
              genericComponentOverrideContext.__assign({}, normalisedConfig),
              {
                onHandleEvent: function(event) {
                  if (normalisedConfig.onHandleEvent !== void 0) {
                    normalisedConfig.onHandleEvent(event);
                  }
                  void Session2.getInstanceOrThrow().notifyListeners(event);
                },
                preAPIHook: function(context) {
                  return genericComponentOverrideContext.__awaiter(_this, void 0, void 0, function() {
                    var response;
                    return genericComponentOverrideContext.__generator(this, function(_a) {
                      response = genericComponentOverrideContext.__assign(
                        genericComponentOverrideContext.__assign({}, context),
                        {
                          requestInit: genericComponentOverrideContext.__assign(
                            genericComponentOverrideContext.__assign({}, context.requestInit),
                            {
                              headers: genericComponentOverrideContext.__assign(
                                genericComponentOverrideContext.__assign(
                                  {},
                                  context.requestInit.headers
                                ),
                                { rid: Session2.RECIPE_ID }
                              )
                            }
                          )
                        }
                      );
                      if (normalisedConfig.preAPIHook === void 0) {
                        return [2, response];
                      } else {
                        return [2, normalisedConfig.preAPIHook(context)];
                      }
                    });
                  });
                }
              }
            )
          )
        };
      };
      Session2.getInstanceOrThrow = function() {
        if (Session2.instance === void 0) {
          throw Error(
            "No instance of Session found. Make sure to call the Session.init method. See https://supertokens.io/docs/emailpassword/quick-setup/frontend"
          );
        }
        return Session2.instance;
      };
      Session2.getInstance = function() {
        return Session2.instance;
      };
      Session2.reset = function() {
        if (!genericComponentOverrideContext.isTest()) {
          return;
        }
        Session2.instance = void 0;
        return;
      };
      Session2.RECIPE_ID = "session";
      return Session2;
    }(index.RecipeModule);
    exports.Session = Session;
    exports.getFailureRedirectionInfo = getFailureRedirectionInfo;
  }
});

export {
  require_windowHandler3 as require_windowHandler,
  require_normalisedURLPath,
  require_utils2 as require_utils,
  require_utils4 as require_utils2,
  require_build,
  require_error3 as require_error,
  require_querier,
  require_authRecipe,
  require_recipe2 as require_recipe,
  require_supertokens_web_js,
  require_cookieHandler4 as require_cookieHandler,
  require_postSuperTokensInitCallbacks2 as require_postSuperTokensInitCallbacks,
  require_windowHandler4 as require_windowHandler2,
  require_multitenancy2 as require_multitenancy,
  require_utils6 as require_utils3,
  require_normalisedURLDomain3 as require_normalisedURLDomain,
  require_normalisedURLPath3 as require_normalisedURLPath2,
  require_jsx_runtime,
  require_genericComponentOverrideContext,
  require_translationContext,
  require_session2 as require_session,
  require_recipeModule_shared,
  require_session_shared2
};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=chunk-LFNHU7DE.js.map
